\documentclass[runningheads,a4paper]{llncs}
\pdfoutput=1

\bibliographystyle{plainurl}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{enumerate}
\usepackage[colorlinks=true]{hyperref}
\usepackage{tikz}
\usepackage{xcolor,latexsym,amsmath,extarrows,alltt}
\usepackage{xspace}
\usepackage{booktabs}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{stmaryrd}
\usepackage{microtype}
\usepackage{bussproofs}
\usepackage{multirow}
\usepackage{proof}
\usepackage[T1]{fontenc}

\newcommand{\Iterms}{\mathcal{I}}
\newcommand{\World}{\mathcal{W}}
\newcommand{\Rules}{\mathcal{R}}
\newcommand{\Typevars}{\mathcal{A}}
\newcommand{\Vars}{\mathcal{V}}
\newcommand{\ITypes}{\mathcal{Y}}
\newcommand{\Types}{\mathcal{T}}
\newcommand{\Terms}{\mathcal{T}\!\mathit{erms}}
\newcommand{\TypeConstructors}{\mathcal{C}}
\newcommand{\TypeQuantifiers}{\mathcal{Q}}
\newcommand{\Typemap}{\mathcal{T\!M}}
\newcommand{\Termmap}{\mathcal{J}}

\newcommand{\nf}{\mathtt{nf}}

\newcommand{\quant}[2]{\forall #1[#2]}
\newcommand{\qquant}[3]{#1 #2[#3]}
\newcommand{\typeinterpret}[1]{\llparenthesis #1 \rrparenthesis}
\newcommand{\interpret}[1]{\llparenthesis #1 \rrparenthesis}
\newcommand{\itp}[1]{\llparenthesis #1 \rrparenthesis}
\newcommand{\arr}[1]{\longrightarrow_{#1}}
\newcommand{\red}{\longrightarrow}
\newcommand{\arrtype}{\rightarrow}
\newcommand{\arrkind}{\Rightarrow}
\newcommand{\abs}[2]{\lambda #1.#2}
\newcommand{\tabs}[2]{\Lambda #1.#2}
\newcommand{\abstraction}[2]{\backslash #1.#2}
\newcommand{\app}[2]{#1 \cdot #2}
\newcommand{\apps}[3]{#1 \cdot #2 \cdots #3}
\newcommand{\tapp}[2]{#1 * #2}
\newcommand{\pair}[2]{\langle #1,#2 \rangle}
\newcommand{\subst}[2]{#1:=#2}
\newcommand{\meta}[2]{#1\langle#2\rangle}

\newcommand{\FTV}{\mathrm{FTV}}
\newcommand{\FV}{\mathrm{FV}}
\newcommand{\Tc}{\mathcal{T}}

\newcommand{\nat}{\mathtt{nat}}
\newcommand{\proj}{\pi}
\newcommand{\flatten}{\mathtt{flatten}}
\newcommand{\lift}{\mathtt{lift}}
\newcommand{\con}{\mathtt{c}}
\newcommand{\afun}{\mathtt{f}}

\newcommand{\ur}{\upharpoonright}
\newcommand{\da}{\downarrow}
\newcommand{\SN}{\mathrm{SN}}
\newcommand{\Cb}{\mathbb{C}}
\newcommand{\Nbb}{\mathbb{N}}
\newcommand{\val}[3]{\ensuremath{\llbracket#1\rrbracket_{#2}^{#3}}}
\newcommand{\proves}{\vdash}

\newcommand{\CK}[1]{\textcolor{blue}{CK: #1}}
\newcommand{\LC}[1]{\textcolor{purple}{LC: #1}}

\begin{document}

\mainmatter

\title{TODO list
  \thanks{The authors are supported by lots of people.}}
\subtitle{What we need to do to get where we want to be}

\author{{\L}ukasz Czajka and Cynthia Kop}
\authorrunning{{\L}. Czajka and C. Kop}
\institute{
Faculty of Informatics, TU Dortmund
\\
Institute of Computer Science, Radboud University Nijmegen (RU)
\\
\email{lukaszcz@mimuw.edu.pl}
\quad\quad\quad
\email{C.Kop@cs.ru.nl}
}

\maketitle

\begin{abstract}
The introduction of this paper is a TODO list.
The remainder is meant for filling in the TODOs with what we already have.
The hope is that the end result is something useful. :)
\end{abstract}

\section*{THE LIST}

\renewcommand{\theenumii}{\arabic{enumi}.\arabic{enumii}}

Here's what we need to do:
\begin{enumerate}
\item Define a world $\World$ and a well-founded ordering $\succ$ on
  $\World$:
  \begin{enumerate}
  \item Define a set of terms $\World$ typed under some variation of
    System F-$\omega$.
  \item Define relations $\succ$ and $\succeq$ on the elements of $\World$.
  \item Prove that $\succ$ is a well-founded ordering relation and that
    $\succeq$ is a compatible quasi-ordering.
  \end{enumerate}
\item Specify what systems we are interested in analysing, and prove
  standard results which will make their analysis doable.
  \begin{enumerate}
  \item Specify a form of system which includes all the systems of interest.
  \item Specify a default way of interpreting terms in these systems.
  \item Prove that in all such systems, using our way of interpreting
    terms: if $\interpret{\ell} \succ \interpret{r}$ (resp.\ $\interpret{
    \ell} \succeq \interpret{r}$) for a rule  $\ell \to r$, then
    $\interpret{s} \succ \interpret{t}$ whenever $s \arr{\Rules} t$ by
    this rule (resp.\ $\interpret{s} \succeq \interpret{t}$).
  \end{enumerate}
\item Obtain useful lemmas regarding these defaults.
  \begin{enumerate}
  \item $\interpret{s[x:=t]} = \interpret{s}[x:=\interpret{t}]$.
  \item $\interpret{s\sigma} = \interpret{s}\sigma$.
  \item \dots?
  \end{enumerate}
\item For some system of interest, prove its termination:
  \begin{enumerate}
  \item Present the system and give interpretations (following the
    default scheme) for all ways of constructing terms.
  \item Show that $\ell \succ r$ or $\ell \succeq r$ for all rules.
    Remove the rules which are oriented using $\succ$ and repeat,
    until all rules have been removed.
  \end{enumerate}
\end{enumerate}

\renewcommand{\theenumii}{\alph{enumii}}

We use \emph{rule removal}:

\begin{theorem}\label{thm:ruleremove}
Let $\Rules = \Rules_1 \cup \Rules_2$, and suppose that $\arr{\Rules_1}\:
\subseteq\:\succ$ and $\arr{\Rules_2}\:\subseteq\:\succeq$ for a
well-founded ordering $\succ$ and a compatible quasi-ordering $\succeq$.
Then $\arr{\Rules}$ is terminating if and only if $\arr{\Rules_2}$ is
(which is certainly the case if $\Rules_2 = \emptyset$).
\end{theorem}

\begin{proof}
By well-foundedness of $\succ$, every infinite decreasing $\arr{\Rules}$
sequence can only use finitely many steps using $\arr{\Rules_1}$.
\qed
\end{proof}

This gives rise to the following algorithm:
\begin{enumerate}
\item While $\Rules$ is non-empty:
  \begin{enumerate}
  \item Orient all rules in $\Rules$ using $\succeq$ or $\succ$; at least
    one of them must be oriented using $\succ$.
  \item Remove all rules ordered by $\succ$ from $\Rules$.
  \end{enumerate}
\end{enumerate}
If this algorithm succeeds, we have proven termination.

\section{Defining a world}

\subsection{Defining the set $\World$}

\subsubsection{Interpretation terms}
We define the set of types for interpretation terms.

Our system of interpretation terms is based on System~$F_\omega$, see
e.g., Sorensen, Urzyczyn, ``Lectures on the Curry-Howard
Isomorphism'', Section~11.7.

\begin{definition}\label{def:itypes}\normalfont
  \emph{Kinds} are defined inductively:
  \begin{itemize}
  \item $*$ is a kind,
  \item if $\kappa_1,\kappa_2$ are kinds then so is $\kappa_1 \arrkind
    \kappa_2$.
  \end{itemize}

  We assume infinitely many \emph{type constructor variables} of each
  kind. Variables of kind~$*$ are \emph{type variables}.

  We define \emph{type constructors} of kind~$\kappa$ by induction.
  Type constructors of kind~$*$ are called \emph{types}.
  \begin{itemize}
  \item A type constructor variable of kind~$\kappa$ is a type
    constructor of kind~$\kappa$.
  \item If $\varphi$ is a type constructor of kind $\kappa_1 \arrkind
    \kappa_2$ and $\psi$ is a type constructor of kind~$\kappa_1$ then
    $\varphi \psi$ is a type constructor of kind~$\kappa_2$.
  \item If $\alpha$ is a type constructor variable of kind~$\kappa_1$
    and $\varphi$ is a type constructor of kind~$\kappa_2$, then
    $\lambda\alpha . \varphi$ is a type constructor of kind $\kappa_1
    \arrkind \kappa_2$.
  \item If $\alpha$ is a type constructor variable of kind~$\kappa$
    and~$\tau$ is a type, then $\forall \alpha[\tau]$ is a type.
  \item If $\tau_1,\tau_2$ are types, then $\tau_1 \arrtype \tau_2$ is
    a type.
  \end{itemize}
  The set of type constructors of kind~$\kappa$ is denoted
  by~$\Tc_\kappa$.

  We use the notation $\forall \alpha . \tau$ and $\forall \alpha
  \tau$. When $\alpha$ is of kind $\kappa$ then we use the notations
  $\forall \alpha : \kappa . \tau$ and $\forall (\alpha :
  \kappa)[\tau]$.

  Beta-reduction on type constructors is defined as the compatible
  closure of the rule
  \[
  (\lambda\alpha.\varphi)\psi \to \varphi[\alpha := \psi]
  \]
  Note that type constructors are essentially simply-typed
  lambda-terms, so beta-reduction on type constructors terminates and
  is confluent, hence every type constructor~$\varphi$ has a unique
  normal form.

  We define $\FV(\varphi)$ -- the set of free type constructor
  variables of the type constructor~$\varphi$ -- in an obvious way by
  induction on the structure of~$\varphi$. A type
  constructor~$\varphi$ is \emph{closed} if $\FV(\varphi) =
  \emptyset$.
\end{definition}

\begin{definition}\label{def_typing}\normalfont
We assume given an infinite set $\Vars$ of variables, and let $\Gamma$
refer to a mapping from a finite subset of $\Vars$ to the set of
interpretation types. The set of interpretation preterms consists of
all expressions $s$ such that $\Gamma \vdash s : \sigma$ can be
inferred for some interpretation type $\sigma$ and mapping $\Gamma$ by
the following clauses:
\begin{itemize}
\item $\Gamma \vdash n : \nat$ for every natural number $n$.
\item $\Gamma \vdash x : \sigma$ for every $(x : \sigma) \in \Gamma$.
\item $\Gamma \vdash \mathtt{f} : \sigma$ for all $(\mathtt{f} :
  \sigma)$ in the following set: $\{ \oplus_\sigma : \sigma \arrtype
  \sigma \arrtype \sigma,\ \otimes_\sigma : \sigma \arrtype \sigma
  \arrtype \sigma,\ \flatten_{\sigma} : \sigma \arrtype
  \nat,\ \lift_{\sigma} : \nat \arrtype \sigma \mid \sigma \in \ITypes
  \}$.
\item $\Gamma \vdash \abs{x:\sigma}{s} : \sigma \arrtype \tau$ if $x
  \in \Vars$ and $\Gamma \uplus \{ x : \sigma \} \vdash s : \tau$.
\item $\Gamma \vdash \tabs{\alpha}{s} : \quant{\alpha}{\sigma}$ if
  $\alpha$ is a type constructor variable and $\Gamma \vdash s :
  \sigma$ and for all $(x : \tau) \in \Gamma$: $\alpha \notin
  \FV(\tau)$
\item $\Gamma \vdash \app{s}{t} : \tau$ if $\Gamma \vdash s : \sigma
  \arrtype \tau$ and $\Gamma \vdash t : \sigma$
\item $\Gamma \vdash \tapp{s}{\tau} : \sigma[\subst{\alpha}{\tau}]$ if
  $\Gamma \vdash s : \quant{(\alpha:\kappa)}{\sigma}$ and~$\tau$ is a
  type constructor of kind~$\kappa$,
\item $\Gamma \vdash s : \tau$ if $\Gamma \vdash s : \tau'$ and $\tau
  =_\beta \tau'$.
\end{itemize}
We say that $s$ is \emph{closed} if $\vdash s : \sigma$ for some
closed $\sigma$ (then also $\FV(s) = \emptyset$).
\end{definition}

If $\alpha$ is a type constructor variable of kind~$\kappa$ then we
use the notation $\tabs{\alpha:\kappa}{t}$.

Note that for a given $\Gamma$, if $s$ is typable under $\Gamma$, then
there is only one choice for the type modulo $\beta$-conversion (this
is easily proved by induction on the form of $s$). Thus, all closed
terms have a unique type modulo $\beta$-conversion.

\begin{definition}
  We define the type equivalence relation~$\equiv$ on preterms by
  induction on preterm structure.
  \begin{itemize}
  \item $x \equiv x$, $n \equiv n$,
  \item if $\sigma =_\beta \tau$ then $f_\sigma \equiv f_\tau$ for $f
    \in \{\oplus,\otimes,\flatten,\lift\}$,
  \item if $\sigma =_\beta \tau$ and $s \equiv t$ then
    $\abs{x:\sigma}{s} \equiv \abs{x:\tau}{t}$,
  \item if $s \equiv t$ then $\tabs{\alpha}{s} \equiv
    \tabs{\alpha}{t}$,
  \item if $s \equiv s'$ and $t \equiv t'$ then $s \cdot t \equiv s'
    \cdot t'$,
  \item if $s \equiv t$ and $\sigma =_\beta \tau$ then
    $\tapp{s}{\sigma} \equiv \tapp{t}{\tau}$.
  \end{itemize}
  In other words, $s \equiv t$ iff $s$ and $t$ are identical modulo
  $\beta$-conversion in types.
\end{definition}

Note that~$\equiv$ is an equivalence relation.

\begin{lemma}
  If $\Gamma \vdash s : \tau$ and $s \equiv t$ then $\Gamma \vdash t :
  \tau$.
\end{lemma}

\begin{proof}
  Induction on~$s$.
\end{proof}

The set $\Iterms$ of interpretation terms is now defined as follows.

\begin{definition}
  The set~$\Iterms$ of \emph{interpretation terms} is the set of the
  equivalence classes of~$\equiv$.
\end{definition}

Because typing and term formation operations (abstraction,
application, \ldots) are invariant under~$\equiv$, we may denote
interpretation terms by their representatives and informally treat
them interchangeably.

\subsubsection{Normalising interpretation terms}
To define the world of \emph{final interpretation terms}, we will
normalise certain elements of $\Iterms$ using the relation $\leadsto$.

\begin{definition}
  We define the relation $\leadsto$ on interpretation terms as the
  smallest relation for which the following properties are satisfied:
  \begin{enumerate}
  \item\label{leadsto:mono:abs}
    if $s \leadsto t$ then both $\abs{x}{s} \leadsto \abs{x}{t}$ and
    $\tabs{\alpha}{s} \leadsto \tabs{\alpha}{t}$
  \item\label{leadsto:mono:right}
    if $s \leadsto t$ then $\app{u}{s} \leadsto \app{u}{t}$
  \item\label{leadsto:mono:left}
    if $s \leadsto t$ then both $\app{s}{u} \leadsto \app{t}{u}$ and
    $\tapp{s}{\sigma} \leadsto \tapp{t}{\sigma}$
  \item\label{leadsto:plus:base}
    $\app{\app{\oplus_{\nat}}{n}}{m} \leadsto (n+m)$
  \item\label{leadsto:times:base}
    $\app{\app{\otimes_{\nat}}{n}}{m} \leadsto (n \cdot m)$
  \item\label{leadsto:circ:arrow} $\app{\app{\circ_{\sigma \arrtype
          \tau}}{s}}{t} \leadsto \abs{x:
      \sigma}{\app{\app{\circ_\tau}{(\app{s}{x})}}{(\app{t}{x})}}$ for
    $\circ \in \{ \oplus, \otimes \}$
  \item\label{leadsto:circ:forall}
    $\app{\app{\circ_{\quant{\alpha}{\sigma}}}{s}}{t} \leadsto
    \tabs{\alpha}{\app{\app{\circ_\sigma}{(\tapp{s}{\alpha})}}{(
        \tapp{t}{\alpha})}}$ for $\circ \in \{ \oplus, \otimes \}$
  \item $\app{\flatten_\nat}{s} \leadsto s$
  \item $\app{\flatten_{\sigma \arrtype \tau}}{s} \leadsto
    \app{\flatten_\tau}{(\app{s}{(\app{\lift_\sigma}{0})})}$
  \item $\app{\flatten_{\quant{\alpha}{\sigma}}}{s} \leadsto
    \app{\flatten_{\sigma[\subst{\alpha}{\nat}]}}{(\tapp{s}{\nat})}$
  \item $\app{\lift_\nat}{s} \leadsto s$
  \item $\app{\lift_{\sigma \arrtype \tau}}{s} \leadsto
    \abs{x:\sigma}{\app{\lift_{\tau}}{s}}$
  \item $\app{\lift_{\quant{\alpha}{\sigma}}}{s} \leadsto
    \tabs{\alpha}{\app{\lift_{\sigma}}{s}}$
  \item\label{leadsto:beta:abs} $\app{(\abs{x:\sigma}{s})}{t} \leadsto
    s[\subst{x}{t}]$
  \item\label{leadsto:beta:tabs} $\tapp{(\tabs{\alpha}{s})}{\sigma}
    \leadsto s[\subst{\alpha}{\sigma}]$.
  \end{enumerate}
  Note that the above rules are invariant under~$\equiv$ (by
  confluence of $\beta$-reduction on types), so they correctly define
  a relation on interpretation terms -- the equivalence classes
  of~$\equiv$.

  We say that $s$ is a \emph{redex} if $s$ reduces by one of the rules
  (\ref{leadsto:plus:base})--(\ref{leadsto:beta:tabs}), and that $s$
  \emph{reduces at the head} to $t$ if the derivation of
  $s \leadsto t$ does not use (\ref{leadsto:mono:abs}) or
  (\ref{leadsto:mono:right}).

  A \emph{final interpretation term} is an interpretation term
  $s \in \Iterms$ such that (a) $s$ is closed, and (b) $s$ is in
  normal form with respect to $\leadsto$.  We let $\World$ be the set
  of all final interpretation terms. By~$\World_\tau$ we denote the
  set of all final interpretation terms of type~$\tau$.
\end{definition}

In the remainder of this section, we shall often speak simply of
``terms'' when referring to interpretation terms.

\subsubsection{Key properties of $\leadsto$}
In the remainder of this section, we will often abuse notation to omit
$\cdot$ and $*$.  Thus, $s t$ can refer to both $\app{s}{t}$ and
$\tapp{s}{t}$. We will also use $\abstraction{a}{s}$ for either
$\abs{a}{s}$ or $\tabs{a}{s}$, depending on the context.

\begin{lemma}[Subject reduction]
  If $\Gamma \vdash t : \tau$ and $t \leadsto t'$ then
  $\Gamma \vdash t' : \tau$.
\end{lemma}

\begin{proof}
  TODO
\end{proof}

By~$\SN$ we denote the set of all terminating pseudoterms. For
$t \in \SN$ by~$\nu(t)$ we denote the length of the longest reduction
starting at~$t$.

The following lemma is obvious, but worth stating explicitly.

\begin{lemma}\label{lem_reduce_abs}
  If $\abstraction{a}{s} \leadsto^* t$, then $t = \abstraction{a}{t'}$
  and $s \leadsto^* t'$.  If $s \in \SN$ then both $\abs{x}{s}$ and
  $\tabs{\alpha}{s}$ are also in $\SN$.
\end{lemma}

\begin{proof}
  We observe that every reduct of $\abstraction{x}{s}$ has the form
  $\abstraction{x}{s'}$ with $s \leadsto s'$, and analogously for
  $\tabs{\alpha}{s}$.  Thus, the first statement follows by induction
  on the length of the reduction $\abstraction{a}{s} \leadsto^* t$,
  and the second statement by induction on $\nu(s)$.  \qed
\end{proof}

\begin{lemma}\label{lem_circ_sn_base}
  If $t_1,t_2 \in \SN$ then $\circ_\nat t_1 t_2 \in \SN$ for $\circ
  \in \{\oplus,\otimes\}$.
\end{lemma}

\begin{proof}
  By induction on $\nu(t_1) + \nu(t_2)$. Assume $t_1,t_2 \in \SN$. To
  prove $\circ_\nat t_1 t_2 \in \SN$ it suffices to show $s \in \SN$
  for all~$s$ such that $\circ_\nat t_1 t_2 \leadsto s$. If $s =
  \circ_\nat t_1' t_2$ or $s = \circ_\nat t_1 t_2'$ with $t_i \leadsto
  t_i'$ then we complete by the induction hypothesis. Otherwise $s \in
  \mathbb{N}$ is obviously in $\SN$.
\end{proof}

\subsubsection{Computability}

In the rest of this section we adapt the Tait-Girard computability
method to prove termination of~$\leadsto$. The proof is an adaptation
of chapters~6 and~14 from the book ``Proofs and Types'' by Girard, and
chapters~10 and~11 from the book ``Lectures on the Curry-Howard
Isomorphism'' by Sorensen and Urzyczyn. An important difference with
system~$F_\omega$ and related ones is that the rules for
$\oplus_\tau$, $\otimes_\tau$, $\flatten_\tau$ and $\lift_\tau$ depend
on the type~$\tau$. This makes adapting the computability method a bit
more difficult.

For the termination proof we assume without loss of generality that
the terms are given in orthodox Church-style, i.e., that each variable
occurrence is annotated with a type. It suffices to prove termination
on orthodox Church-style typed terms, because any infinite reduction
on an interpretation term induces an infinite reduction on the
corresponding orthodox Church-style typed term.

We denote an occurrence of a variable~$x$ annotated with a type~$\tau$
by~$x^\tau$. So now
e.g.~$\lambda x : \tau\arrtype\sigma . x^{\tau\arrtype\sigma}y^\tau$
is an orthodox Church-style typed term. We often omit the type
annotations for readability. Note that now type substitution also
needs to change the type annotations. Also, each term has a unique
type modulo $\beta$-conversion. We write $t : \tau$ if $t$ has
type~$\tau$.

\begin{definition}\label{def_candidate}\normalfont
  A term~$t$ is \emph{neutral} if there does not exists a sequence of
  terms or types~$u_1,\ldots,u_n$ with $n \ge 1$ such that
  $t u_1 \ldots u_n$ is a redex (by~$\leadsto$).

  By induction on the kind~$\kappa$ of a type constructor~$\tau$ we
  define the set~$\Cb_\tau$ of all candidates of type
  constructor~$\tau$.

  First assume $\kappa=*$, i.e., $\tau$ is a type. A set~$X$ of
  interpretation terms of type~$\tau$ is a \emph{candidate of
    type~$\tau$} when:
  \begin{enumerate}
  \item $X \subseteq \SN$;
  \item if $t \in X$ and $t \leadsto t'$ then $t' \in X$;
  \item if $t$ is neutral and for every~$t'$ with $t \leadsto t'$ we
    have $t' \in X$, then $t \in X$;
  \item if $t_1,t_2 \in X$ then $\circ_\tau t_1 t_2 \in X$ for
    $\circ \in \{\oplus,\otimes\}$;
  \item if $t \in \SN$ and $t : \nat$ then $\lift_\tau(t) \in X$.
  \end{enumerate}
  Note that item~3 above implies:
  \begin{itemize}
  \item if $t$ is neutral and in normal form then $t \in X$.
  \end{itemize}

  Now assume $\kappa = \kappa_1\arrkind\kappa_2$. A function
  $f : \Tc_{\kappa_1} \times \bigcup_{\xi\in\Tc_{\kappa_1}}\Cb_\xi \to
  \bigcup_{\xi\in\Tc_{\kappa_2}}\Cb_\xi$ is a \emph{candidate of type
    constructor~$\tau$} if for every type constructor~$\sigma$ of
  kind~$\kappa_1$ and a candidate $X \in \Cb_\sigma$ we have
  $f(\sigma,X) \in \Cb_{\tau\sigma}$.
\end{definition}

Note that the elements of a candidate of type~$\tau$ are required to
have type~$\tau$.

\begin{lemma}
  If $\sigma =_\beta \sigma'$ then $\Cb_\sigma = \Cb_{\sigma'}$.
\end{lemma}

\begin{proof}
  Induction on the kind of~$\sigma$.
\end{proof}

\begin{definition}\label{def_reducibility_valuation}\normalfont
  Let $\omega$ be a mapping from type constructor variables to type
  constructors (respecting kinds). The mapping~$\omega$ extends in an
  obvious way to a mapping from type constructors to type
  constructors. An \emph{$\omega$-valuation} is a mapping~$\xi$ from
  type constructor variables to candidates such that
  $\xi(\alpha) \in \Cb_{\omega(\alpha)}$.

  For each type constructor~$\sigma$, each mapping~$\omega$ and each
  $\omega$-valuation~$\xi$, the set $\val{\sigma}{\xi}{\omega}$ is
  defined by induction on~$\sigma$:
  \begin{itemize}
  \item $\val{\alpha}{\xi}{\omega} = \xi(\alpha)$ for a type
    constructor variable~$\alpha$,
  \item $\val{\nat}{\xi}{\omega}$ is the set of all terms~$t \in \SN$
    such that $t : \nat$,
  \item $\val{\sigma \arrtype \tau}{\xi}{\omega}$ is the set of all
    terms~$t$ such that $t : \omega(\sigma\arrtype\tau)$ and for
    every~$s \in \val{\sigma}{\xi}{\omega}$ we have
    $\app{t}{s} \in \val{\tau}{\xi}{\omega}$,
  \item $\val{\forall(\alpha:\kappa)[\sigma]}{\xi}{\omega}$ is
    the set of all terms~$t$ such that
    $t : \omega(\forall\alpha[\sigma])$ and for every type
    constructor~$\tau$ of kind~$\kappa$ and every $X \in \Cb_\tau$ we
    have
    $\tapp{t}{\tau} \in
    \val{\sigma}{\xi[\subst{\alpha}{X}]}{\omega[\subst{\alpha}{\tau}]}$,
  \item
    $\val{\varphi \psi}{\xi}{\omega} =
    \val{\varphi}{\xi}{\omega}(\omega(\psi),\val{\psi}{\xi}{\omega})$,
  \item
    $\val{\lambda(\alpha:\kappa)\varphi}{\xi}{\omega}(\tau,X) =
    \val{\varphi}{\xi[\subst{\alpha}{X}]}{\omega[\subst{\alpha}{\tau}]}$
    for $\tau \in \Tc_\kappa$ and $X \in \Cb_\tau$.
  \end{itemize}
  In the last two point, if
  e.g.~$\val{\psi}{\xi}{\omega} \notin \Cb_{\omega(\psi)}$ then
  $\val{\varphi \psi}{\xi}{\omega}$ is undefined.
\end{definition}

\begin{lemma}\label{lem_nat_reducible}
  $\val{\nat}{\xi}{\omega} \in \Cb_{\nat}$.
\end{lemma}

\begin{proof}
  We check the conditions in Definition~\ref{def_candidate}.
  \begin{enumerate}
  \item $\val{\nat}{\xi}{\omega} \subseteq \SN$ follows
    directly from Definition~\ref{def_reducibility_valuation}.
  \item Let $t \in \val{\nat}{\xi}{\omega}$ and $t \leadsto t'$. Then
    $t : \nat$ and $t \in \SN$. Hence $t' \in \SN$, and $t' : \nat$ by
    the subject reduction lemma. Thus
    $t' \in \val{\nat}{\xi}{\omega}$.
  \item Let $t$ be neutral and $t : \nat$. Assume that for all~$t'$
    with $t \leadsto t'$ we have $t' \in \val{\nat}{\xi}{\omega}$, so
    in particular $t' \in \SN$. But then $t \in \SN$. Hence
    $t \in \val{\nat}{\xi}{\omega}$.
  \item Let $t_1,t_2 \in \SN$ be such that $t_i : \nat$. Obviously,
    $\circ_\nat t_1 t_2 : \nat$. Also $\circ_\nat t_1 t_2 \in \SN$
    follows by Lemma~\ref{lem_circ_sn_base}. So
    $\circ_\nat t_1 t_2 \in \val{\nat}{\xi}{\omega}$.
  \item Let $t \in \SN$ be such that $t : \nat$. Then
    $\lift_\nat t : \nat$. It remains to show $\lift_\nat t \in
    \SN$. Any infinite reduction from~$\lift_\nat t$ has the form
    $\lift_\nat t \leadsto^* \lift_\nat t_0 \leadsto t_1 \leadsto t_2
    \leadsto \ldots$ or
    $\lift_\nat t \leadsto \lift_\nat t_0 \leadsto \lift_\nat t_1
    \leadsto \lift_\nat t_2 \leadsto \ldots$, where $t \leadsto^* t_0$
    and $t_i \leadsto t_{i+1}$. This contradicts $t \in \SN$.
  \end{enumerate}
\end{proof}

\begin{lemma}\label{lem_abstraction_computable}
  Let $\sigma,\tau$ be types. Suppose
  $\val{\tau}{\xi'}{\omega'} \in \Cb_{\omega'(\tau)}$ and
  $\val{\sigma}{\xi'}{\omega'} \in \Cb_{\omega'(\sigma)}$ for all
  suitable $\omega',\xi'$. Then
  \begin{itemize}
  \item
    $\abs{x:\omega(\tau)}{s} \in \val{\tau \arrtype
      \sigma}{\xi}{\omega}$ if and only if
    $\abs{x:\omega(\tau)}{s} : \omega(\tau \arrtype \sigma)$ and
    $s[x:=t] \in \val{\sigma}{\xi}{\omega}$ for all
    $t \in \val{\tau}{\omega,\xi}{}$;
  \item
    $\tabs{\alpha}{s} \in
    \val{\quant{(\alpha:\kappa)}{\sigma}}{\xi}{\omega}$ if and only if
    $\tabs{\alpha}{s} : \omega(\quant{(\alpha:\kappa)}{\sigma})$ and
    for every type constructor~$\varphi$ of kind~$\kappa$ and all
    $X \in \Cb_\varphi$ we have
    $s[\alpha:=\varphi] \in
    \val{\sigma}{\xi[\subst{\alpha}{X}]}{\omega[\subst{\alpha}{\varphi}]}$.
  \end{itemize}
\end{lemma}

\begin{proof}
  First suppose
  $\abs{x:\omega(\tau)}{s} \in \val{\tau \arrtype
    \sigma}{\xi}{\omega}$. Then
  $\abs{x:\omega(\tau)}{s} : \omega(\tau\arrtype\sigma)$ and for all
  $t \in \val{\tau}{\xi}{\omega}$ we have
  $\app{(\abs{x:\omega(\tau)}{s})}{t} \in \val{\sigma}{\xi}{\omega}$.
  As this set is a candidate, it is closed under $\leadsto$, so also
  $s[x:=t] \in \val{\sigma}{\xi}{\omega}$. Similarly, if
  $\tabs{\alpha}{s} \in \val{\quant{\alpha}{\sigma}}{\xi}{\omega}$,
  then $\tabs{\alpha}{s} : \quant{\alpha}{\sigma}$ and
  $\tapp{(\tabs{\alpha}{s})}{\varphi} \in
  \val{\sigma}{\xi[\subst{\alpha}{X}]}{\omega[\subst{\alpha}{\varphi}]}$,
  and we are done because
  $\tapp{(\tabs{\alpha}{s})}{\tau} \leadsto s[\alpha:=\varphi]$ and
  $\val{\sigma}{\xi[\subst{\alpha}{X}]}{\omega[\subst{\alpha}{\varphi}]}$
  is a candidate, so it is closed under~$\leadsto$.

  Now suppose $s[x:=t] \in \val{\sigma}{\xi}{\omega}$ for all
  $t \in \val{\tau}{\xi}{\omega}$. Let
  $t \in \val{\tau}{\xi}{\omega}$. Then $t \in \SN$ because
  $\val{\tau}{\xi}{\omega}$ is a candidate. Also $s \in \SN$ because
  every infinite reduction in $s$ induces an infinite reduction in
  $s[x:=t]$ ($\leadsto$ is stable) and
  $\val{\sigma}{\xi}{\omega} \subseteq \SN$ is a candidate. For all
  $s',t'$ with $s \leadsto^* s'$ and $t \leadsto^* t'$, we show by
  induction on~$\nu(s') + \nu(t')$ that
  $\app{(\abs{x}{s'})} t' \in \val{\sigma}{\xi}{\omega}$. We have
  $\app{(\abs{x}{s'})} t' : \omega(\sigma)$ by definition and the
  subject reduction theorem (note that $t : \omega(\tau)$ because
  $\val{\tau}{\xi}{\omega} \in \Cb_{\omega(\tau)}$). The set
  $\val{\sigma}{\xi}{\omega}$ is a candidate, and
  $\app{(\abs{x}{s'})}{t'}$ is neutral, so in
  $\val{\sigma}{\xi}{\omega}$ if all its reducts are. Thus assume
  $\app{(\abs{x}{s'})}{t'} \leadsto u$. If
  $u = \app{(\abs{x}{s'})}{t''}$ with $t' \leadsto t''$ or
  $u = \app{(\abs{x}{s''})}{t'}$ with $s' \leadsto s''$, then
  $u \in \val{\sigma}{\xi}{\omega}$ by the inductive hypothesis. So
  assume $u = s'[x:=t']$. We have $s[x:=t] \leadsto^* s'[x:=t']$ by
  monotonicity and stability of $\leadsto$. Therefore
  $u = s'[x:=t'] \in \val{\sigma}{\xi}{\omega}$, because
  $s[x:=t] \in \val{\sigma}{\xi}{\omega}$ and
  $\val{\sigma}{\xi}{\omega}$ is a candidate and hence closed under
  $\leadsto$.

  A similar reasoning applies to $s[\alpha:=\varphi]$.
\end{proof}

\begin{lemma}\label{lem_val_computable}
  $\val{\sigma}{\omega,\xi}{\Gamma} \in \Cb_{\omega(\sigma)}^\Gamma$.
\end{lemma}

\begin{proof}
  By induction on~$\sigma$ we show that
  $\val{\sigma}{\omega,\xi}{\Gamma} \in \Cb_{\omega(\sigma)}^\Gamma$
  for all suitable $\Gamma,\omega,\xi$. First, if $\sigma = \alpha$
  for a type constructor variable~$\alpha$ then
  $\val{\sigma}{\omega,\xi}{\Gamma} = \xi(\alpha) \in
  \Cb_{\omega(\sigma)}^\Gamma$ by definition. If $\sigma = \nat$ then
  $\val{\nat}{\omega,\xi}{\Gamma} \in \Cb_{\nat}^\Gamma$ by
  Lemma~\ref{lem_nat_reducible}.

  Assume $\sigma = \tau_1 \arrtype \tau_2$. We check the conditions in
  Definition~\ref{def_candidate}.
  \begin{enumerate}
  \item Let $t \in \val{\tau_1\arrtype\tau_2}{\omega,\xi}{\Gamma}$ and
    assume there is an infinite reduction
    $t \leadsto t_1 \leadsto t_2 \leadsto t_3 \leadsto \ldots$. Let
    $x$ be fresh and $\Gamma' = \Gamma,x:\omega(\tau_1)$. By the
    inductive hypothesis $\val{\tau_1}{\omega,\xi}{\Gamma'}$ and
    $\val{\tau_2}{\omega,\xi}{\Gamma'}$ are candidates. So
    $x \in \val{\tau_1}{\omega,\xi}{\Gamma}$ because it is neutral and
    normal. Then $t x \in \val{\tau_2}{\omega,\xi}{\Gamma}$. Thus
    $t x$~is strongly normalising. But
    $t x \leadsto t_1 x \leadsto t_2 x \leadsto t_3 x \leadsto
    \ldots$. Contradiction.
  \item Let $t \in \val{\tau_1\arrtype\tau_2}{\omega,\xi}{\Gamma}$ and
    $t \leadsto t'$. Let $u \in
    \val{\tau_1}{\omega,\xi}{\Gamma}$. Then
    $t u \in \val{\tau_2}{\omega,\xi}{\Gamma}$. By the inductive
    hypothesis $\val{\tau_2}{\omega,\xi}{\Gamma}$ is a candidate, so
    $t' u \in \val{\tau_2}{\omega,\xi}{\Gamma}$. Also note that
    $\Gamma \proves t' : \omega(\tau_1 \arrtype \tau_2)$ by the subject
    reduction lemma. Hence
    $t' \in \val{\tau_1\arrtype\tau_2}{\omega,\xi}{\Gamma}$.
  \item Let $t$ be neutral and
    $\Gamma \proves t : \omega(\tau_1 \arrtype \tau_2)$ and assume for
    every~$t'$ with $t \leadsto t'$ we have
    $t' \in \val{\tau_1\arrtype\tau_2}{\omega,\xi}{\Gamma}$. Let
    $u \in \val{\tau_1}{\omega,\xi}{\Gamma}$. By the inductive
    hypothesis $\val{\tau_1}{\omega,\xi}{\Gamma}$ is a candidate, so
    $u \in \SN$. By induction on~$\nu(u)$ we show that
    $t u \in \val{\tau_2}{\omega,\xi}{\Gamma}$. Assume
    $t u \leadsto t''$. We show
    $t'' \in \val{\tau_2}{\omega,\xi}{\Gamma}$. Because~$t$ is
    neutral, $t u$ cannot be a redex. So there are two cases.
    \begin{itemize}
    \item $t'' = t u'$ with $u \leadsto u'$. Then
      $t u' \in \val{\tau_2}{\omega,\xi}{\Gamma}$ by the inductive
      hypothesis for~$u$.
    \item $t'' = t' u$ with $t \leadsto t'$. Then
      $t' \in \val{\tau_1\arrtype\tau_2}{\omega,\xi}{\Gamma}$, so
      $t' u \in \val{\tau_2}{\omega,\xi}{\Gamma}$.
    \end{itemize}
    We have thus shown that if $t u \leadsto t''$ then
    $t'' \in \val{\tau_2}{\omega,\xi}{\Gamma}$. By the (main)
    inductive hypothesis $\val{\tau_2}{\omega,\xi}{\Gamma}$ is a
    candidate, and $t u$ is neutral, so also
    $t u \in \val{\tau_2}{\omega,\xi}{\Gamma}$. Since
    $u \in \val{\tau_1}{\omega,\xi}{\Gamma}$ was arbitrary, we have
    shown $t \in \val{\tau_1\arrtype\tau_2}{\omega,\xi}{\Gamma}$.
  \item Assume $t_1,t_2 \in \val{\tau_1\arrtype\tau_2}{\omega,\xi}{\Gamma}$.
    We have already shown that this implies $t_1,t_2 \in \SN$.
    Since $s := \circ_{\omega(\tau_1\arrtype\tau_2)} t_1 t_2$ is neutral,
    we have also already seen that $s \in \val{\tau_1\arrtype\tau_2}{\omega,
    \xi}{\Gamma}$ if $s' \in \val{\tau_1\arrtype\tau_2}{\omega,\xi}{\Gamma}$
    whenever $s \leadsto s'$.
    This we show by induction on $t_1,t_2$ (oriented with $\leadsto$).
    If $s' = \circ_{\omega(\tau_1\arrtype\tau_2)} t_1' t_2$, then note that
    $t_1' \in \val{\tau_1\arrtype\tau_2}{\omega,\xi}{\Gamma}$ because we
    have already shown that $\val{\tau_1\arrtype\tau_2}{\omega,\xi}{\Gamma}$
    is closed under $\leadsto$; thus, we can complete by the induction
    hypothesis.
    If $s' = \circ_{\omega(\tau_1\arrtype\tau_2)} t_1 t_2'$, we complete in
    the same way.
    The only alternative is that $s' = \abs{x:\omega(\tau_1)}{\circ_{
    \omega(\tau_2)} (t_1 x) (t_2 x)}$.
    Let $u \in \val{\tau_1}{\omega,\xi}{\Gamma}$.  Since $t_1,t_2 \in
    \val{\tau_1\arrtype\tau_2}{\omega,\xi}{\Gamma}$, we have that $t_1 u$
    and $t_2 u$ are in $\val{\tau_2}{\omega,\xi}{\Gamma}$ by
    definition.  Since, $\val{\tau_2}{\omega,\xi}{\Gamma}$ is a
    candidate, this means that $\circ_{\omega(\tau_2)} (t_1 u) (t_2 u) =
    (\circ_{\omega(\tau_2)} (t_1 x) (t_2 x))[x:=u]$ is in
    $\val{\tau_2}{\omega,\xi}{\Gamma}$ as well.  By
    Lemma~\ref{lem_abstraction_computable}, we conclude that $s' \in
    \val{\tau_1\arrtype\tau_2}{\omega,\xi}{\Gamma}$.
  \item
  \end{enumerate}

  Assume $\sigma = \forall\alpha[\tau]$. We check the conditions in
  Definition~\ref{def_candidate}.
  \begin{enumerate}
  \item Let $t \in \val{\forall\alpha[\tau]}{\omega,\xi}{\Gamma}$ and
    assume there is an infinite reduction
    $t \leadsto t_1 \leadsto t_2 \leadsto t_3 \leadsto
    \ldots$. Let~$\tau'$ be an arbitrary type and let
    $S \in \Cb_{\tau'}^\Gamma$ (e.g.~take~$S$ to be the set of
    terminating terms of type~$\tau'$ in context~$\Gamma$).
    \CK{It is not guaranteed that this will work! For that we really
    do need that $\circ s t$ is SN if $s$ and $t$ are.  However, can't
    we just take $\tau' := \nat$?} \LC{I think $\tau' := \nat$ indeed works here.}
    Then
    $t \tau' \in
    \val{\tau}{\omega[\subst{\alpha}{\tau'}],\xi[\subst{\alpha}{S}]}{\Gamma}$. By
    the inductive hypothesis
    $\val{\tau}{\omega[\subst{\alpha}{\tau'}],\xi[\subst{\alpha}{S}]}{\Gamma}$
    is a candidate, so $t \tau' \in \SN$. But
    $t \tau' \leadsto t_1 \tau' \leadsto t_2 \tau' \leadsto t_3 \tau'
    \leadsto \ldots$. Contradiction.
  \item Let $t \in \val{\forall\alpha[\tau]}{\omega,\xi}{\Gamma}$ and
    $t \leadsto t'$. By the subject reduction lemma
    $\Gamma \proves t' : \omega(\forall\alpha[\tau])$. Let~$\tau'$ be
    a type and~$X \in \Cb_{\tau'}^\Gamma$. Then
    $t \tau' \in
    \val{\tau}{\omega[\subst{\alpha}{\tau'}],\xi[\subst{\alpha}{X}]}{\Gamma}$. By
    the inductive hypothesis
    $\val{\tau}{\omega[\subst{\alpha}{\tau'}],\xi[\subst{\alpha}{X}]}{\Gamma}$
    is a candidate, so
    $t' \tau' \in
    \val{\tau}{\omega[\subst{\alpha}{\tau'}],\xi[\subst{\alpha}{X}]}{\Gamma}$. Therefore
    $t' \in \val{\forall\alpha[\tau]}{\omega,\xi}{\Gamma}$.
  \item Let $t$ be neutral and
    $\Gamma \proves t : \omega(\forall\alpha[\tau])$ and assume for
    every~$t'$ with $t \leadsto t'$ we have
    $t' \in
    \val{\forall\alpha[\tau]}{\omega,\xi}{\Gamma}$. Let~$\tau'$ be a
    type and~$X \in \Cb_{\tau'}^\Gamma$. Assume
    $t \tau' \leadsto t''$. Then $t'' = t' \tau'$ with
    $t \leadsto t'$, because~$t$ is neutral. Hence
    $t \tau' \leadsto t' \tau' \in
    \val{\tau}{\omega[\subst{\alpha}{\tau'}],\xi[\subst{\alpha}{X}]}{\Gamma}$. By
    the inductive
    hypothesis~$\val{\tau}{\omega[\subst{\alpha}{\tau'}],\xi[\subst{\alpha}{X}]}{\Gamma}$
    is a candidate, and also $t \tau'$ is neutral, so
    $t \tau' \in
    \val{\tau}{\omega[\subst{\alpha}{\tau'}],\xi[\subst{\alpha}{X}]}{\Gamma}$. This
    implies that
    $t \in \val{\forall\alpha[\tau]}{\omega,\xi}{\Gamma}$.
  \item Assume
    $t_1,t_2 \in \val{\forall\alpha[\tau]}{\omega,\xi}{\Gamma}$. We
    have already shown that this implies $t_1,t_2 \in \SN$, and since
    $s := \circ_{\omega(\forall\alpha[\tau])} t_1 t_2$ is neutral, that
    $s \in \val{\forall\alpha[\tau]}{\omega,\xi}{\Gamma}$ if $s' \in
    \val{\forall\alpha[\tau]}{\omega,\xi}{\Gamma}$ whenever $s \leadsto
    s'$.  This we show by induction on $t_1,t_2$.
    The cases when $t_1$ or $t_2$ are reduced are immediate with the
    induction hypotheses; the only remaining case is when $s' =
    \tabs{\alpha}{\circ_{\omega(\tau)} (t_1 \alpha) (t_2 \alpha)}$.
    For all types $\sigma$ and $X \in \Cb_{\sigma}^\Gamma$ we have both
    $t_1 \sigma$ and $t_2 \sigma$ in $\val{\tau}{\omega[\subst{\alpha}{
    \sigma}],\xi[\subst{\alpha}{X}]}{\Gamma}$ (by definition of
    $t_1,t_2 \in \val{\forall\alpha[\tau]}{\omega,\xi}{\Gamma}$).
    But then, because $\val{\tau}{\omega[\subst{\alpha}{\sigma}],
    \xi[\subst{\alpha}{X}]}{\Gamma}$ is a candidate by the inductive
    hypothesis, we have $\circ_{\omega(\tau[\subst{\alpha}{\sigma})}
    (t_1 \sigma) (t_2\sigma) = (\circ_{\omega(\tau)} (t_1 \alpha) (t_2
    \alpha))[\subst{\alpha}{\sigma}] \in \val{\tau}{\omega[\subst{
    \alpha}{\sigma}],\xi[\subst{\alpha}{X}]}{\Gamma}$ for all types
    $\sigma$, so $s' \in \val{\forall\alpha[\tau]}{\omega,\xi}{\Gamma}$
    by Lemma~\ref{lem_abstraction_computable}.
  \end{enumerate}

  Assume $\sigma = \varphi\psi$. We check the conditions in
  Definition~\ref{def_candidate}.
  \begin{enumerate}
  \item
  \end{enumerate}
\end{proof}

\begin{lemma}\label{lem_val_subst}
  $\val{\sigma[\subst{\alpha}{\tau}]}{\omega,\xi}{\Gamma} =
  \val{\sigma}{\omega[\subst{\alpha}{\tau}],\xi[\subst{\alpha}{\val{\tau}{\omega,\xi}{\Gamma}}]}{\Gamma}$.
\end{lemma}

\begin{proof}
  TODO
\end{proof}

\begin{lemma}
  $\circ_{\omega(\sigma)} \in \val{\sigma \arrtype \sigma \arrtype
    \sigma}{\omega,\xi}{\Gamma}$ for
  $\circ \in \{ \oplus, \otimes \}$.
\end{lemma}

\begin{proof}
  Follows from Definition~\ref{def_typing} and
  Lemma~\ref{lem_val_computable}.
\end{proof}

\begin{lemma}
  $\flatten_{\omega(\sigma)} \in
  \val{\sigma\arrtype\nat}{\omega,\xi}{\Gamma}$.
\end{lemma}

\begin{proof}
  TODO
\end{proof}

\begin{lemma}
  $\lift_{\omega(\sigma)} \in
  \val{\nat\arrtype\sigma}{\omega,\xi}{\Gamma}$.
\end{lemma}

\begin{proof}
  TODO
\end{proof}

\begin{lemma}
  If $t \in \val{\forall\alpha[\sigma]}{\omega,\xi}{\Gamma}$ then
  $t \tau \in \val{\sigma[\subst{\alpha}{\tau}]}{\omega,\xi}{\Gamma}$
  for any type~$\tau$.
\end{lemma}

\begin{proof}
  By Lemma~\ref{lem_val_computable} the
  set~$\val{\tau}{\omega,\xi}{\Gamma}$ is a candidate of
  type~$\tau$. By hypothesis
  $t \tau \in
  \val{\sigma}{\omega[\subst{\alpha}{\tau}],\xi[\subst{\alpha}{\val{\tau}{\omega,\xi}{\Gamma}}]}{\Gamma}$. Hence
  $t \tau \in \val{\sigma[\subst{\alpha}{\tau}]}{\omega,\xi}{\Gamma}$
  by Lemma~\ref{lem_val_subst}.
\end{proof}

\begin{lemma}\label{lem_typable_computable}
  If $\Gamma \proves t : \sigma$ then
  $\omega(t) \in \val{\sigma}{\omega,\xi}{\Gamma}$.
\end{lemma}

\begin{proof}
  Idea: by induction on~$t$, using the previous lemmas. One
  generalizes the inductive hypothesis to: if
  $x_1 : \tau_1,\ldots,x_n:\tau_n \proves t : \sigma$ then for all
  $u_1\in\val{\tau_1}{\omega,\xi}{\Gamma},\ldots,u_n\in\val{\tau_n}{\omega,\xi}{\Gamma}$
  we have
  $\omega(t[\subst{x_1}{u_1},\ldots,\subst{x_n}{u_n}]) \in
  \val{\sigma}{\omega,\xi}{\Gamma}$.
\end{proof}

\begin{corollary}
  If $\Gamma \proves t : \sigma$ then $t \in \SN$.
\end{corollary}

\begin{proof}
  Follows from Lemma~\ref{lem_typable_computable},
  Lemma~\ref{lem_val_computable} and Definition~\ref{def_candidate}.
\end{proof}

\begin{lemma}
Every term $s \in \Iterms$ with $\FV(s) = \emptyset$ reduces
to a unique final interpretation term $s\downarrow$.
\end{lemma}

\begin{proof}
By proving termination and local confluence of $\leadsto$ (although it
actually suffices to only prove local confluence for fully closed terms).

TODO.
\qed
\end{proof}

\begin{lemma}\label{lem_final_nat}
The only final interpretation terms of type $\nat$ are the natural
numbers.
\end{lemma}

\begin{proof}
  This is~NOT~TRUE. Consider
  $\oplus_{\nat\arrtype\nat} \lift_\nat \lift_\nat n$. Need to add more
  rewrite rules?
  \CK{Better now?} \LC{Yes, I think it works now.}
\end{proof}

\subsection{Defining $\succ$ and $\succeq$}

We will define $\succ$ and $\succeq$ on elements of $\Iterms$, using
coinduction: $s \succ t$ (resp.\ $s \succeq t$) if $s \succ_\sigma t$
(resp.\ $s \succeq_\sigma t$) can be obtained for $\sigma$ the type of
$s,t$, following Definition~\ref{def:succ}.

\begin{definition}\label{def:succ}
  Let $R \in \{ \succ,\succeq \}$. For~$s,t \in \Iterms_\sigma$, the
  relation $s\ R_{\sigma}\ t$ is defined coinductively by the
  following rules.
  \[
    \begin{array}{c}
    \infer={s\ R_\nat\ t}{s\da\ R\ t\da \text{ in natural
        numbers}}\quad\quad
    \infer={s\ R_{\sigma\arrtype\tau}\ t}{\app{s}{q}\ R_{\tau}\ \app{t}{q}
      \text{ for every } q \in \World_\sigma} \\ \\
    \infer={s\ R_{\forall\alpha[\sigma]}\ t}{\tapp{s}{\tau}\ R_{\sigma[\subst{\alpha}{\tau}]}\ \tapp{t}{\tau}
      \text{ for every closed type } \tau}
    \end{array}
  \]
\end{definition}

Note that in the case for~$\nat$ the terms~$s\da$, $t\da$ are natural
numbers by Lemma~\ref{lem_final_nat}.

\LC{This definition was incorrect before, because e.g.~$\app{s}{q}$
  need not be in normal form. I think it's best just to define it from
  the start for all terms in~$\Iterms$.}

\subsection{Properties of $\succ$ and $\succeq$}

We're going to at least need to see that $\succ$ is a well-founded
ordering:

\begin{lemma}
$\succ$ is well-founded.
\end{lemma}

\begin{proof}
  By induction on the size of the type~$\tau$ one shows that there
  does not exist an infinite sequence $t_1 \succ_\tau t_2 \succ_\tau
  t_3 \succ_\tau \ldots$ For instance, if $t_1
  \succ_{\forall\alpha[\tau]} t_2 \succ_{\forall\alpha[\tau]} t_3
  \succ_{\forall\alpha[\tau]} \ldots$ then $\tapp{t_1}{\nat}
  \succ_{\tau[\subst{\alpha}{\nat}]} \tapp{t_2}{\nat}
  \succ_{\tau[\subst{\alpha}{\nat}]} \tapp{t_3}{\nat}
  \succ_{\tau[\subst{\alpha}{\nat}]} \ldots$, which is impossible by
  the inductive hypothesis.
\end{proof}

\begin{lemma}
Both $\succ$ and $\succeq$ are transitive.
\end{lemma}

\begin{proof}
  We show this for~$\succeq$, the proof for~$\succ$ being
  analogous. We proceed by coinduction.

  If $t_1 \succeq_\nat t_2 \succeq_\nat t_3$ then
  $t_1\da \ge t_2\da \ge t_3\da$, so $t_1\da \ge t_3\da$. Thus
  $t_1 \succeq_\nat t_3$.

  If $t_1 \succeq_{\sigma\arrtype\tau}t_2\succeq_{\sigma\arrtype\tau}t_3$ then
  $\app{t_1}{q}\succeq_{\tau}\app{t_2}{q}\succeq_\tau\app{t_3}{q}$ for
  $q \in \World_\sigma$. Hence $\app{t_1}{q}\succeq_\tau\app{t_3}{q}$
  for $q \in \World_\sigma$ by the coinductive hypothesis. Thus
  $t_1\succeq_{\sigma\arrtype\tau} t_3$.

  If $t_1
  \succeq_{\forall\alpha[\sigma]}t_2\succeq_{\forall\alpha[\sigma]}t_3$
  then
  $\tapp{t_1}{\tau}\succeq_{\sigma[\subst{\alpha}{\tau}]}\tapp{t_2}{\tau}\succeq_{\sigma[\subst{\alpha}{\tau}]}\tapp{t_3}{\tau}$
  for any closed type~$\tau$. Hence
  $\tapp{t_1}{\tau}\succeq_{\sigma[\subst{\alpha}{\tau}]}\tapp{t_3}{\tau}$
  by the coinductive hypothesis. Thus
  $t_1\succeq_{\forall\alpha[\sigma]} t_3$.\qed
\end{proof}

And that $\succeq$ is a quasi-ordering:

\begin{lemma}
$\succeq$ is reflexive.
\end{lemma}

\begin{proof}
  By coinduction.\qed
\end{proof}

Finally, they must be compatible:

\begin{lemma}\label{lem:compatibility}
We have $\succ \cdot \succeq\ \subseteq\ \succ$
\end{lemma}

\begin{proof}
By coinduction, analogous to the transitivity proof.\qed
\end{proof}

\CK{Do we also have $\succeq \cdot \succ\ \subseteq\ \succ$? I'd like
to use that.\medskip} \LC{Yes, with an analogous proof.}

\CK{I think that's all that absolutely \emph{has} to be proven to make
  the argument work. However, to work with these things we will need a
  little more\dots}

No longer needed: In the following, we extend $\succ$ and $\succeq$ to
non-final interpretation terms, by defining $s \succ t$ (resp. $s
\succeq t$) if $s\downarrow \succ t\da$ (resp. $s\downarrow \succeq
t\downarrow$).  \CK{Note that for this we do need to prove that
  $\leadsto$ has unique normal forms, but if we don't define this,
  then the following lemma is meaningless, I think.}  \LC{I don't
  think there is any problem with local confluence, and we have SN
  (but this should be re-checked). Besides, this already beaks down
  without unique normal forms with the definition for~$\World$, so I
  changed the definition to make it work for~$\Iterms$ from the
  start.}

\begin{lemma}\label{lem:plusparts}
For all \emph{closed} interpretation types $\sigma$, interpretation
terms $s,t$ of type $\sigma$ and $n > 0$ we have:
\begin{enumerate}
\item $\oplus_{\sigma} s t \succeq s$ and
      $\oplus_{\sigma} s t \succeq t$;
\item $\oplus_{\sigma} s (\lift_{\sigma}(n)) \succ s$ and
      $\oplus_{\sigma} (\lift_{\sigma}(n)) t \succ t$.
\end{enumerate}
\end{lemma}

\begin{proof}
TODO

\LC{I think these also hold by coinduction because they hold for
  type~$\nat$. But one needs to generalize the coinductive hypothesis
  to $\app{\app{\oplus}{s}}{t} t_1 \ldots t_n \succeq_\sigma s t_1
  \ldots t_n$.}

\end{proof}

\begin{lemma}\label{lem:liftgreater}
If $n \geq m$ then $\lift_\sigma(n) \succeq \lift_\sigma(m)$ for all
\emph{closed} types $\sigma$.
\end{lemma}

\begin{proof}
TODO
\end{proof}

\begin{lemma}\label{lem:plustimesmonotonic}
If $s,t,u$ are terms of a \emph{closed} type $\sigma$ and $s \succeq
t$, then $s \oplus_\sigma u \succeq t \oplus_\sigma u$ and $s
\otimes_\sigma u \succeq t \otimes_\sigma u$.  Moreover, if even $s
\succ t$ then we have $s \oplus_\sigma u \succ t$, and if $u \succeq
\lift_\sigma(1)$ then also $s \otimes_\sigma u \succ t \otimes_\sigma
u$.
\end{lemma}

\begin{proof}
TODO
\end{proof}

In the following, we denote $s \approx t$ if both $s \succeq t$ and
$t \succeq s$.  We observe that standard equality properties of
addition and multiplication extend to interpretation terms of extended
types:

\begin{lemma}\label{lem:approxproperties}
For all \emph{closed} interpretation types $\sigma$ and all
interpretation terms $s,t,u$ of type $\sigma$, we have:
\begin{enumerate}
\item\label{lem:approx:symmetry}
  $\oplus_\sigma s t \approx \oplus_\sigma t s$ and
  $\otimes_\sigma s t \approx \otimes_\sigma t s$;
\item\label{lem:approx:assoc} $\oplus_\sigma s (\oplus_\sigma t u)
  \approx \oplus_\sigma(\oplus_\sigma s t) u$ and $\otimes_\sigma s
  (\otimes_\sigma t u) \approx \otimes_\sigma(\otimes_\sigma s t) u$;
\item\label{lem:approx:distribution} $\otimes_\sigma s (\oplus t u)
  \approx \oplus_\sigma(\otimes_\sigma s t) (\otimes_\sigma s u)$;
\item\label{lem:approx:neutral} $\oplus_\sigma(\lift_\sigma(0)) s
  \approx s$ and $\otimes_\sigma(\lift_\sigma(1)) s \approx s$.
\end{enumerate}
\end{lemma}

\begin{proof}
TODO
\end{proof}

\section{Systems of interest and their properties}\label{sec:systems}

The systems of interest are sets of terms with a rewriting relation on
them. Interestingly, $\Iterms$ can be seen as an instance of this
general scheme.

\subsection{Systems of interest}

We use a syntax similar to that of System $F_\omega$, see e.g.,
Sorensen, Urzyczyn, ``Lectures on the Curry-Howard Isomorphism'',
Section~11.7.

\begin{definition}\normalfont
  \emph{Kinds} are defined inductively:
  \begin{itemize}
  \item $*$ is a kind,
  \item if $\kappa_1,\kappa_2$ are kinds then so is $\kappa_1 \arrkind
    \kappa_2$.
  \end{itemize}

  We assume infinitely many \emph{type constructor variables} of each
  kind. Variables of kind~$*$ are \emph{type variables}.

  We assume a fixed set~$\Sigma_T$ of \emph{type constructor symbols}
  paired with a kind, denoted $c : \kappa$. Every type constructor
  symbol~$c$ occurs only with one kind declaration.

  We define \emph{type constructors} of kind~$\kappa$ by induction.
  Type constructors of kind~$*$ are called \emph{types}.
  \begin{itemize}
  \item A type constructor variable or a type constructor symbol of
    kind~$\kappa$ is a type constructor of kind~$\kappa$.
  \item If $\varphi$ is a type constructor of kind $\kappa_1 \arrkind
    \kappa_2$ and $\psi$ is a type constructor of kind~$\kappa_1$ then
    $\varphi \psi$ is a type constructor of kind~$\kappa_2$.
  \item If $\alpha$ is a type constructor variable of kind~$\kappa_1$
    and $\varphi$ is a type constructor of kind~$\kappa_2$, then
    $\lambda\alpha . \varphi$ is a type constructor of kind $\kappa_1
    \arrkind \kappa_2$.
  \item If $\alpha$ is a type constructor variable of kind~$\kappa$
    and~$\tau$ is a type, then $\forall \alpha[\tau]$ is a type.
  \item If $\tau_1,\tau_2$ are types, then $\tau_1 \arrtype \tau_2$ is
    a type.
  \end{itemize}

  We use the notation $\forall \alpha . \tau$ and $\forall \alpha
  \tau$. When $\alpha$ is of kind $\kappa$ then we use the notations
  $\forall \alpha : \kappa . \tau$ and $\forall (\alpha :
  \kappa)[\tau]$.

  Beta-reduction on type constructors is defined as the compatible
  closure of the rule
  \[
  (\lambda\alpha.\varphi)\psi \to \varphi[\alpha := \psi]
  \]
  Note that type constructors are essentially simply-typed
  lambda-terms, so beta-reduction on type constructors terminates and
  is confluent, hence every type constructor~$\varphi$ has a unique
  normal form. To save on notation we therefore treat type
  constructors modulo $\beta$-conversion. More precisely, type
  constructors could be defined as beta-equivalence classes of the
  above terms, but for readability we work with type constructors in a
  naive way. This is justified by the fact that all basic operations
  on type constructors (substitution, abstraction, etc.) are invariant
  under $\beta$-conversion. So for instance, if $\alpha,\beta$ are
  type constructor variables, then we consider $(\alpha \tau)[\alpha
    := \lambda \beta . \beta]$ (which is $(\lambda \beta . \beta)
  \tau$) and $\tau$ to be the same.
\end{definition}

Terms are built from a set of function symbols, using abstraction and
application as for interpretation terms.

\begin{definition}
We assume given a fixed set $\Sigma$ of \emph{function symbols}, each
paired with a \emph{closed} type, denoted $\mathtt{f} : \tau$.  Every
function symbol $\mathtt{f}$ occurs only with one type declaration.

The set $\Terms$ of terms consists of those expressions $s$ such that
$\Gamma \vdash s : \sigma$ can be derived for some type $\sigma$ and
environment $\Gamma$ using the following clauses:
\begin{itemize}
\item $\Gamma \vdash x : \sigma$ for every $(x : \sigma) \in \Gamma$.
\item $\Gamma \vdash \mathtt{f}_{\rho_1,\ldots,\rho_n}(s_1,\dots,s_k)
  : \tau[\alpha_1 := \rho_1]\ldots[\alpha_n := \rho_n]$ if
  \[
  \mathtt{f} : \forall (\alpha_1 : \kappa_1) \ldots
  \forall (\alpha_n : \kappa_n) . \sigma_1 \arrtype \ldots \arrtype
  \sigma_k \arrtype \tau
  \]
  is a function symbol in~$\Sigma$, and $\rho_i$ is a type constructor
  of kind $\kappa_i$ for $i=1,\ldots,k$, and $\Gamma \vdash s_i :
  \sigma_i[\alpha_1 := \rho_1]\ldots[\alpha_n := \rho_n]$ for
  $i=1,\ldots,k$.
\item $\Gamma \vdash \abs{x:\sigma}{s} : \sigma \arrtype \tau$ if $x
  \in \Vars$ and $\Gamma \uplus \{ x : \sigma \} \vdash s : \tau$.
\item $\Gamma \vdash \tabs{\alpha}{s} : \quant{\alpha}{\sigma}$ if
  $\alpha$ is a type constructor variable and $\Gamma \vdash s :
  \sigma$ and for all $(x : \tau) \in \Gamma$: $\alpha \notin
  \FTV(\tau)$.
\end{itemize}
\end{definition}

We use the notation
$\mathtt{f}_{\rho_1,\ldots,\rho_n}(s_1,\ldots,s_k)$ to stress the fact
that by default there is no explicit application
available. Application can be modelled by including the symbol ${@} :
\forall\alpha\forall\beta . (\alpha \arrtype \beta) \arrtype \alpha
\arrtype \beta$ in $\Sigma$. Similarly, type application is modelled
through a symbol $\mathtt{A} : \forall \alpha : * \arrkind * . \forall
\beta . (\forall \beta [\alpha \beta]) \arrtype \alpha \beta$.

The rules are simply an infinite set of term pairs, whose monotonic
closure generates the rewrite relation. \LC{Now the set of rules can
  be finite.}

\begin{definition}
We fix an infinite variable environment $\Gamma$,
and assume given a set $\Rules$ of term pairs $(\ell,r)$, such that:
\begin{itemize}
\item $\FV(r) \subseteq \FV(\ell) \subseteq \mathit{keys}(\Gamma)$;
\item $\ell$ and $r$ have the same type under $\Gamma$;
\item $\Rules$ is stable: if $(\ell,r) \in \Rules$ and $\gamma$ is a
  (\LC{term substitution? this should also be required for type
  substitutions, I think}) substitution, then $(\ell\gamma,r\gamma)
  \in \Rules$.
\end{itemize}
The reduction relation $\arr{\Rules}$ is the smallest monotonic
relation that contains $\Rules$.
\end{definition}

\LC{I removed $\FTV(\ell) = \FTV(r) = \emptyset$, because we need type
  variables (and also higher-kinded type constructor variables) to
  express the rules. In what we had earlier free type variables were
  there ``implicitly'' in function symbol indexes.}

\subsubsection{An example system.}

For the system of urzy\_emb, we have the following type constructor
symbols:
\[
\begin{array}{c}
\TypeConstructors = \{\quad
  \bot : *,\quad
  \mathtt{or} : * \arrkind * \arrkind *,\quad
  \mathtt{and} : * \arrkind * \arrkind *,\quad
  \exists : (* \arrkind *) \arrkind *
  \}\quad \cup\quad
  \{\quad \mathtt{prop}_i : * \mid i \in \mathbb{N}\quad \}
\end{array}
\]
Here $\mathtt{prop}_i$ represents the $i$-th propositional variable.

We have the following function symbols:
\[
\begin{array}{rcl}
@ & : & \forall \alpha \forall \beta . (\alpha \arrtype \beta) \arrtype \alpha \arrtype \beta \\
\mathtt{tapp} & : & \forall \alpha : * \arrkind * . \forall \beta .
  (\forall \beta [\alpha \beta]) \arrtype \alpha \beta \\
\epsilon & : & \forall \alpha . \bot \arrtype \alpha \\
\mathtt{pair} & : & \forall \alpha \forall \beta . \alpha \arrtype \beta \arrtype
  \mathtt{and}\, \alpha\, \beta \\
\pi^1 & : & \forall \alpha \forall \beta . \mathtt{and}\, \alpha\, \beta \arrtype \alpha \\
\pi^2 & : & \forall \alpha \forall \beta . \mathtt{and}\, \alpha\, \beta \arrtype \beta \\
\mathtt{in}^1 & : & \forall \alpha \forall \beta . \alpha \arrtype
  \mathtt{or}\, \alpha\, \beta \\
\mathtt{in}^2 & : & \forall \alpha \forall \beta . \beta \arrtype
  \mathtt{or}\, \alpha\, \beta \\
\mathtt{case} & : & \forall \alpha \forall \beta \forall \gamma . \mathtt{or}\, \alpha\, \beta \arrtype
  (\alpha \arrtype \gamma) \arrtype (\beta \arrtype \gamma) \arrtype \gamma \\
\mathtt{let} & : & \forall \alpha : * \arrkind * . \forall \beta .
  (\exists (\alpha)) \arrtype
  (\forall \gamma . \alpha \gamma \arrtype \beta) \arrtype \beta \\
\mathtt{ext} & : & \forall \alpha : * \arrkind * . \forall \beta . \alpha \beta \arrtype
  \exists (\alpha)
\end{array}
\]
\LC{If we want this to work for open terms then we should also say
  that for every variable in the original system there is a function
  symbol. If we are satified with termination on closed terms, then we
  don't need $\mathtt{prop}_i$}.

\LC{In fact, I think it's clearer to do this for closed terms only,
  because then termination for open terms follows by closing them with
  lambda-abstractions.}

\LC{You had some mistakes in the rules below. I think these were only
  typos, but re-check if the interpretation still works. Though the
  rules in the last group were all wrong -- the types didn't match.}

And finally the rules.
\[
\begin{array}{rcl}
@_{\sigma,\tau}(\abs{x}{s},t) & \red & s[x:=t] \\
\mathtt{tapp}_{\quant{\alpha}{\sigma},\tau}(\tabs{\alpha}{s}) & \red &
  s[\alpha:=\tau] \\
\pi^1_{\sigma,\tau}(\mathtt{pair}_{\sigma,\tau}(s,t)) & \red & s \\
\pi^2_{\sigma,\tau}(\mathtt{pair}_{\sigma,\tau}(s,t)) & \red & s \\
\mathtt{case}_{\sigma,\tau,\rho}(\mathtt{in}^1_{\sigma,\tau}(u),
  \abs{x}{s},\abs{y}{t}) & \red & s[x:=u] \\
\mathtt{case}_{\sigma,\tau,\rho}(\mathtt{in}^2_{\sigma,\tau}(u),
  \abs{x}{s},\abs{y}{t}) & \red & t[x:=u] \\
\mathtt{let}_{\varphi,\rho}(\mathtt{ext}_{\varphi,\tau}(s),\tabs{\alpha}{\abs{x:\varphi \alpha}{t}}) & \red & t[\alpha:=\tau][x:=s] \\
\end{array}
\]
\[
\begin{array}{rcl}
\epsilon_\tau(\epsilon_\bot(s)) & \red & \epsilon_\tau(s) \\
@_{\sigma,\tau}(\epsilon_{\sigma \arrtype \tau}(s),t) & \red &
  \epsilon_\tau(s) \\
\mathtt{tapp}_{\varphi,\tau}(
  \epsilon_{\quant{\alpha}{\varphi\alpha}}(s)) & \red &
  \epsilon_{\varphi\tau}(s) \\
\pi^1_{\sigma,\tau}(\epsilon_{\mathtt{and}\,\sigma\,\tau}(s)) & \red &
  \epsilon_\sigma(s) \\
\pi^2_{\sigma,\tau}(\epsilon_{\mathtt{and}\,\sigma\,\tau}(s)) & \red &
  \epsilon_\tau(s) \\
\mathtt{case}_{\sigma,\tau,\rho}(\epsilon_{\mathtt{or}\,\sigma\,\tau}(
  u),\abs{x:\sigma}{s},\abs{y:\tau}{t}) & \red & \epsilon_\rho(u) \\
\mathtt{let}_{\varphi,\rho}(\epsilon_{\forall\alpha[\varphi\alpha]}(s),\tabs{\alpha}{\abs{x:\varphi\alpha}{t}}) & \red &
  \epsilon_\rho(s) \\
\end{array}
\]
\begin{itemize}
%\[
%\begin{array}{rcl}
\item $
\epsilon_\rho(\mathtt{case}_{\sigma,\tau,\bot}(u,\abs{x:\sigma}{s},\abs{y:\tau}{t}))
  %& \red &
  \red
  \mathtt{case}_{\sigma,\tau,\rho}(u,\abs{x:\sigma}{\epsilon_\rho(s)},
  \abs{y:\tau}{\epsilon_\rho(t)}) $%\\
\item $
@_{\rho,\pi}(\mathtt{case}_{\sigma,\tau,\rho \arrtype \pi}(u,
  \abs{x:\sigma}{s},\abs{y:\tau}{t}),v) %& \red &
  \red
  \mathtt{case}_{\sigma,\tau,\pi}(u,
  \abs{x:\sigma}{@_{\rho,\pi}(s,v)},\abs{y:\tau}{@_{\rho,\pi}(t,v)}) $%\\
\item $
\mathtt{tapp}_{\varphi,\pi}(\mathtt{case}_{\sigma,\tau,
  \quant{\alpha}{\varphi\alpha}}(u,\abs{x:\sigma}{s},\abs{y:\tau}{t})) %& \red &
  \red
  \mathtt{case}_{\sigma,\tau,\varphi\pi}(u,
  \abs{x:\sigma}{\mathtt{tapp}_{\varphi,\pi}(s)},\\
  \abs{y:\tau}{\mathtt{tapp}_{\varphi,\pi}(t)}) $%\\
\item $
\pi^1_{\rho,\pi}(\mathtt{case}_{\sigma,\tau,\mathtt{and}\,\rho\,\pi}(u,
\abs{x:\sigma}{s},\abs{y:\tau}{t})) %& \red &
  \red
  \mathtt{case}_{\sigma,\tau,\rho}(u,\abs{x:\sigma}{\pi^1_{\rho,\pi}(s)},
  \abs{y:\tau}{\pi^1_{\rho,\pi}(t)}) $%\\
\item $
\pi^2_{\rho,\pi}(\mathtt{case}_{\sigma,\tau,\mathtt{and}\,\rho,\pi}(u,
  \abs{x:\sigma}{s},\abs{y:\tau}{t})) %& \red &
  \red
  \mathtt{case}_{\sigma,\tau,\pi}(u,\abs{x:\sigma}{\pi^2_{\rho,\pi}(s)},
  \abs{y:\tau}{\pi^2_{\rho,\pi}(t)}) $%\\
\item $
\mathtt{case}_{\rho,\pi,\xi}(\mathtt{case}_{\sigma,\tau,\mathtt{or}\,
  \rho\,\pi}(u,\abs{x:\sigma}{s},\abs{y:\tau}{t}),\abs{z:\rho}{v},\abs{a:\pi}{w}) %& \red &
  \red\\
  \mathtt{case}_{\sigma,\tau,\xi}(u,
    \abs{x:\sigma}{\mathtt{case}_{\rho,\pi,\xi}(s,\abs{z:\rho}{v},\abs{a:\pi}{w})},
    \abs{y:\tau}{\mathtt{case}_{\rho,\pi,\xi}(t,\abs{z:\rho}{v},\abs{a:\pi}{w})}) $%\\
\item $
    \mathtt{let}_{\varphi,\rho}(
  \mathtt{case}_{\sigma,\tau,\exists\varphi}(
  u,\abs{x:\sigma}{s},\abs{y:\tau}{t}),v) %& \red &
  \red\\
  \mathtt{case}_{\sigma,\tau,\rho}(u,
  \abs{x:\sigma}{\mathtt{let}_{\varphi,\rho}(s,v)},
  \abs{y:\tau}{\mathtt{let}_{\varphi,\rho}(t,v)})
  $%\\
%\end{array}
%\]
\end{itemize}
\LC{The following rules were wrong. The types didn't match -- you
  forgot the lambda-abstractions.}
\begin{itemize}
\item
  $\epsilon_\tau(\mathtt{let}_{\varphi,\bot}(s,\tabs{\alpha}{\abs{x:\varphi\alpha}{t}}))
  \red
  \mathtt{let}_{\varphi,\tau}(s,\tabs{\alpha}{\abs{x:\varphi\alpha}{\epsilon_\tau(t)}})$
\item $@_{\tau,\rho}(\mathtt{let}_{\varphi, \tau \arrtype
  \rho}(s,\tabs{\alpha}{\abs{x:\varphi\alpha}{t}}),u) \red
  \mathtt{let}_{\varphi,\rho}(s,\tabs{\alpha}{\abs{x:\varphi\alpha}{@_{\tau,\rho}(t,
      u)}})$
\item
  $\mathtt{tapp}_{\psi,\rho}(\mathtt{let}_{\varphi,\forall\beta[\psi\beta]}(s,\tabs{\alpha}{\abs{x:\varphi\alpha}{t}}))
  \red
  \mathtt{let}_{\varphi,\psi\rho}(s,\tabs{\alpha}{\abs{x:\varphi\alpha}{\mathtt{tapp}_{\psi,\rho}(t)}})$
\item
  $\pi^1_{\tau,\rho}(\mathtt{let}_{\varphi,
  \mathtt{and}\,\tau,\rho}(s,\tabs{\alpha}{\abs{x:\varphi\alpha}{t}}))
  \red
  \mathtt{let}_{\varphi,\tau}(s,\tabs{\alpha}{\abs{x:\varphi\alpha}{\pi^1_{\tau,
        \rho}(t)}})$
\item
  $\pi^2_{\tau,\rho}(\mathtt{let}_{\varphi,
  \mathtt{and}\,\tau\,\rho}(s,\tabs{\alpha}{\abs{x:\varphi\alpha}{t}}))
  \red
  \mathtt{let}_{\varphi,\rho}(s,\tabs{\alpha}{\abs{x:\varphi\alpha}{\pi^2_{\tau,\rho}(t)}})$
\item $\mathtt{case}_{\tau,\rho,\pi}(
  \mathtt{let}_{\varphi,\mathtt{or}\,\tau\,\rho}(s,\tabs{\alpha}{\abs{x:\varphi\alpha}{t}}),\abs{x:\tau}{u},\abs{y:\rho}{v})
  \red
  \mathtt{let}_{\varphi,\pi}(s,\tabs{\alpha}{\abs{x:\varphi\alpha}{\mathtt{case}_{\tau,\rho,\pi}(t,\abs{x:\tau}{u},\abs{y:\rho}{v})}})$
\item
  $\mathtt{let}_{\psi,\rho}(\mathtt{let}_{\varphi,\exists\psi}(s,\tabs{\alpha}{\abs{x:\varphi\alpha}{t}}),u)
  \red
  \mathtt{let}_{\varphi,\rho}(s,\tabs{\alpha}{\abs{x:\varphi\alpha}{\mathtt{let}_{\psi,\rho}(t,u)}})$
\end{itemize}

\LC{To be completely precise we should define a translation $\Phi$
  from the system urzy\_emb to the above and show that if $s \red t$
  in urzy\_emb then $\Phi(s) \red \Phi(t)$. But this should be easy
  once the reductions are defined correctly.}

\subsection{Interpreting interesting terms}

All terms will be mapped to interpretation terms, which are compared
using $\succ$ to hopefully obtain a decrease that can be used with
rule removal.

\LC{I think to make things simple we should base interpretation terms
  on System~$F_\omega$ instead of System~$F$. The SN proof should be
  easy to adapt to~$F_\omega$, we get a straightforward mapping, and
  there are strictly more systems we can show termination of
  (e.g. System~$F_\omega$ and extensions). Below I assume we have
  System $F_\omega$ as the basis of our interpretation terms.}

\begin{definition}
A \emph{type constructor mapping} is a function $\Typemap$ which maps
a type constructor symbol to an interpretation type constructor of the
same kind.

A fixed type mapping $\Typemap$ is extended inductively to a function
from type constructors to interpretation type constructors in the
expected way. We denote the extended mapping
by~$\typeinterpret{\sigma}$.
\end{definition}

Thus, for example $\typeinterpret{\quant{\alpha}{\sigma}} =
\quant{\alpha}{\typeinterpret{\sigma}}$ and $\typeinterpret{\sigma
\arrtype \tau} = \typeinterpret{\sigma} \arrtype \typeinterpret{\tau}$.

Similarly, we employ a \emph{symbol mapping} as an aid to interpret
\emph{terms}.

\begin{definition}
A \emph{symbol mapping} is a function $\Termmap$ which assigns to each
function symbol $\mathtt{f} : \rho$ a closed interpretation term
$\Termmap(\mathtt{f})$ of type~$\typeinterpret{\rho}$. For a fixed
symbol mapping $\Termmap$, we define $\interpret{s}$ as follows:
\[
\begin{array}{rcl}
\interpret{x} & = & x \\
\interpret{\tabs{\alpha}{s}} & = & \tabs{\alpha}{\interpret{s}} \\
\interpret{\abs{x:\sigma}{s}} & = & \abs{x:\typeinterpret{\sigma}}{
  \interpret{s}} \\
\interpret{f_{\rho_1,\dots,\rho_n}(s_1,\dots,s_k)} & = &
  \Termmap(f) \typeinterpret{\rho_1} \ldots \typeinterpret{\rho_n} \interpret{s_1} \ldots \interpret{s_k}
\end{array}
\]

Symbol mapping is extended to contexts as follows:
\[
\itp{\Gamma} := \{ (x : \typeinterpret{\tau}) \mid (x : \tau) \in \Gamma \}
\]
\end{definition}

Interpretation mapping preserves typing, in a sense:

\begin{lemma}
If $\Gamma \vdash s : \sigma$ then $\itp{\Gamma} \vdash \interpret{s}
: \typeinterpret{\sigma}$.
\end{lemma}

\begin{proof}
By induction on the form of $s$.  The variable case is obvious. The
case where $s$ is an abstraction $\abs{x:\tau}{s'}$ or a type
abstraction $\tabs{\alpha}{s'}$ are both immediate with the induction
hypothesis and the definition of type interpretation.  So consider the
case where $s = f_{\rho_1,\dots,\rho_n}(s_1,\dots,s_k)$. We have:
\begin{itemize}
\item $f : \rho$ where
  \[
  \rho = \forall \alpha_1 \ldots \forall \alpha_n . \tau_1 \arrtype
  \dots \arrtype \tau_k \arrtype \sigma \in \Sigma
  \]
  for some $\vec{\tau},\sigma$;
\item by definition of~$\Termmap$ we have $\itp{\Gamma} \vdash
  \Termmap(f) : \typeinterpret{\rho}$; and
  \[
  \typeinterpret{\rho} = \forall \alpha_1 \ldots \forall \alpha_n
  . \typeinterpret{\tau_1} \arrtype \dots \arrtype
  \typeinterpret{\tau_k} \arrtype \typeinterpret{\sigma} \in \Sigma
  \]
\item writing $\tau_i' := \tau_i[\alpha_1:=\rho_1]\dots[\alpha_n:=
  \rho_n]$ for $1 \leq i \leq k$, we have $\Gamma \vdash s_i :
  \tau_i'$;
\item by the induction hypothesis, $\itp{\Gamma} \vdash
  \interpret{s_i} : \typeinterpret{\tau_i'}$;
\item hence $\itp{\Gamma} \vdash \interpret{s_i} :
  \typeinterpret{\tau_i}[\alpha_1:=\typeinterpret{\rho_1}]\ldots[\alpha_n:=\typeinterpret{\rho_n}]$
  by Lemma~\ref{lem:substitutioninterpret};
\item we have
  \[
  \interpret{s} = \Termmap(f) \typeinterpret{\rho_1} \ldots
  \typeinterpret{\rho_n} \interpret{s_1} \ldots \interpret{s_k}
  \]
\item hence $\itp{\Gamma} \vdash \interpret{s} :
  \typeinterpret{\rho}$.\qed
\end{itemize}
\end{proof}

\subsection{Monotonicity}

By imposing certain monotonicity requirements on the choices for
$\Termmap$, we obtain a pair $(\succ,\succeq)$ that can be used with
rule removal (Theorem \ref{thm:ruleremove}).

\CK{%
The idea is that if $s \arr{\Rules} t$ then $\interpret{s}\downarrow\:
\succ\:\interpret{t}\downarrow$ must hold (or $\interpret{s}\downarrow\:
\succeq\:\interpret{t}\downarrow$, but in that case the rule cannot be
removed).  This will likely require that every component of a function
symbol is represented; for instance a requirement such as: if
$\Termmap(\mathtt{f}) = \abs{x_1 \dots x_n}{s}$, then $s = s_1 \oplus
\dots \oplus s_n + t$ where for $i$: if $x_i$ increases strictly,
then also $s_i$ increases.
(This would perhaps be simpler with interpretations to $\mathbb{N}
\setminus \{ 0 \}$, as then a component $\lift(\flatten(x_1)) \otimes
x_2$ would be strict in both $x_1$ and $x_2$, rather than in neither.)
Note that the restrictions should at least allow for the current
definition of $\Termmap(\mathtt{ext})$.}

\CK{In addition, we might need stability: if I can prove that
$\interpret{\ell} \downarrow \succ \interpret{r}\downarrow$ we should
also have $\interpret{\ell\gamma}\downarrow \succ
\interpret{r\gamma}\downarrow$ for all substitutions and type
substitutions $\gamma$.  (Not sure
about this one, as the rules already occur in instantiated form.)}

\LC{It's not completely obvious to me how to do this, so I'd like to
  see this spelled out in detail.}

%\begin{lemma}
%TODO
%\end{lemma}
%
%Thus, if $\interpret{\ell} \succ \interpret{r}$ for some rule, then
%$\interpret{s}\downarrow \succ \interpret{t}\downarrow$ whenever
%$s \arr{\Rules} t$ by that rule, and similar for $\succeq$.  This
%provides a strategy for termination analysis using rule removal.

\section{Some useful lemmas}

Some things I will need:

\begin{lemma}\label{lem:substitutioninterpret}
We have:
\begin{enumerate}
\item\label{lem:substitutioninterpret:types}
  $\typeinterpret{\sigma}[\alpha:=\typeinterpret{\tau}] =
  \typeinterpret{\sigma[\alpha:=\tau]}$
\item\label{lem:substitutioninterpret:mixed}
  $\interpret{s}[\alpha:=\typeinterpret{\tau}] =
  \interpret{s[\alpha:=\tau]}$
\item\label{lem:substitutioninterpret:terms}
  $\interpret{s}[x:=\interpret{t}] = \interpret{s[x:=t]}$
\end{enumerate}
\end{lemma}

\begin{proof}
TODO
\end{proof}

\subsection{Orienting $\beta$-reduction}

\subsection{Orienting type instantiation}

\subsection{Other}

\section{Some systems of interest -- urzy\_emb?}

For easier presentation, we will denote $\oplus$ and $\otimes$ in
\emph{infix, left-associative} notation, and omit the type denotation
where it is clear from context.  Thus, $s \oplus t \oplus u$ should be
read as $\oplus_\sigma\,s\,(\oplus_\sigma\,t\,u)$ if $s$ has type
$\sigma$. Similarly, we will sometimes omit the type denotation from
$\flatten$ and $\lift$ when it can easily be derived from context.

\subsection{Interpretations}

We use the following type constructor mapping:
\[
\begin{array}{rcl}
\Typemap(\bot) & = & \nat \\
\Typemap(\mathtt{or}) & = & \lambda\alpha_1\lambda\alpha_2 . \alpha_1 \times \alpha_2 \\
\Typemap(\mathtt{and}) & = & \lambda\alpha_1\lambda\alpha_2 . \alpha_1 \times \alpha_2 \\
\Typemap(\mathtt{prop}_i) & = & \nat \\
\Typemap(\exists) & = & \lambda(\alpha : * \arrkind *) . \quant{\beta}{\quant{\gamma}{\alpha\gamma \arrtype \beta} \arrtype \beta}
\end{array}
\]
And the following function symbol mapping:
\[
\begin{array}{rcll}
\Termmap(\epsilon) & = & \Lambda \alpha:* . \lambda x:\nat. &
  \mathtt{lift}_\alpha(x) \\
\Termmap(@) & = & \Lambda\alpha\Lambda\beta\lambda x: \alpha \arrtype \beta . \lambda y :
  \alpha . \quad & x \cdot y \oplus \lift_\beta(\flatten_\alpha(
  y) \oplus 1) \\
\Termmap(\mathtt{tapp}) & = & \Lambda \alpha : * \arrkind * . \Lambda \beta . \lambda x : \quant{\gamma}{\alpha\gamma} . \quad & x * \beta \oplus \lift_{\alpha\beta}(1) \\
\Termmap(\mathtt{ext}) & = & \Lambda \alpha : * \arrkind * . \Lambda \beta : * . \lambda x:\alpha\beta . &
  \tabs{\xi}{\abs{y:\quant{\chi}{\alpha\chi
  \arrtype \xi}}{y * \beta \cdot x}} \\
\Termmap(\mathtt{in}^1) & = & \Lambda \alpha \Lambda \beta \lambda x : \alpha.\quad &
  (x, \mathtt{lift}_\beta(1)) \\
\Termmap(\mathtt{in}^2) & = & \Lambda \alpha \Lambda \beta \lambda x : \beta.\quad &
  (\mathtt{lift}_\alpha(1), x) \\
\Termmap(\pi^1) & = & \Lambda \alpha \Lambda \beta \lambda x : \alpha \times \beta.
  \quad & \pi^1_{\alpha,\beta}(x) \oplus \lift_{\alpha}(1) \\
\Termmap(\pi^2) & = & \Lambda \alpha \Lambda \beta \lambda x : \alpha \times \beta.
  \quad & \pi^2_{\alpha,\beta}(x) \oplus \lift_{\beta}(1) \\
\Termmap(\mathtt{pair}) & = & \Lambda \alpha \Lambda \beta \lambda x : \alpha, y :
  \beta.\quad & (x, y) \\
\end{array}
\]
\[
\begin{array}{rcl}
\Termmap(\mathtt{let}) & = & \Lambda \alpha : * \arrkind * . \Lambda \beta : * . \lambda x : \quant{\chi}{
  \quant{\xi}{\alpha\xi \arrtype \chi} \arrtype \chi},
  y : \quant{\xi}{\alpha\xi \arrtype \beta}. \\
  & & \hfill x * \beta \cdot y \oplus \lift_{\beta}(\flatten(y) \oplus
  1) \\
\Termmap(\mathtt{case}) & = & \Lambda \alpha,\beta,\xi . \lambda x : (\alpha
  \times \beta), y : (\alpha \arrtype \xi), z : (\beta \arrtype \xi). \\
  & & \quad
  \lift_\xi(37) \oplus (\ \lift_\xi(\flatten_{\alpha \times\beta}(
  x) \oplus 1) \otimes \\
  & & \phantom{\quad\lift_\xi(37) \oplus a}\
  ((y \cdot \proj^1_{\alpha,\beta}(x)) \oplus
   (z \cdot \proj^2_{\alpha,\beta}(x)) \oplus \lift_\xi(1))
  \ ) \\
\end{array}
\]

\subsection{Rule orientation}

\LC{The following should be adapted to the new notation and
  re-checked, because some rules were incorrect.}

\begin{itemize}
\item $@_{\sigma,\tau}(\abs{x}{s},t) \red s[x:=t]$ \\
  We have $\interpret{@(\abs{x:\sigma}{s},t)} = (\abs{x:\typeinterpret{
  \sigma}}{\interpret{s}}) \cdot \interpret{t} \oplus \lift(\flatten(
  \interpret{t}) \oplus 1) \leadsto \interpret{s}[x:=\interpret{t}]
  \oplus \lift(\flatten(\interpret{t}) \oplus 1)$.  Since, by Lemma
  \ref{lem:liftgreater} we have $\lift(\flatten(\interpret{t}) \oplus
  1) \succeq \lift(1)$, by Lemma \ref{lem:plustimesmonotonic} this term
  $\succ \interpret{s}[x:=\interpret{t}]$, which equals
  $\interpret{s[x:=t]}$ by Lemma \ref{lem:substitutioninterpret}.
  Thus, we can remove this rule.
\item $\mathtt{tapp}_{\quant{\alpha}{\sigma},\tau}(\tabs{\alpha}{s})
  \red s[\alpha:=\tau]$ \\ We have
  $\interpret{\mathtt{tapp}_{\quant{\alpha}{\sigma},
      \tau}(\tabs{\alpha}{s})} = (\tabs{\alpha}{\interpret{s}}) *
  \typeinterpret{\tau} \oplus \lift(1) \leadsto \interpret{s}[\alpha:=
    \typeinterpret{\tau}] \oplus \lift(1) \succ
  \interpret{s}[\alpha:=\typeinterpret{\tau}] =
  \interpret{s[\alpha:=\tau]}$.  Thus, we can remove this rule.
\item $\mathtt{let}_{\qquant{\forall}{\alpha}{\sigma},\rho}(
  \mathtt{ext}_{\qquant{\forall}{\alpha}{\sigma},\tau}(s),\tabs{\alpha}{
    \abs{x:\sigma}{t}}) \red t[\alpha:=\tau][x:=s]$ \\
  Let $u := \mathtt{ext}_{\quant{\alpha}{\sigma},\tau}(s)$ and
  $w := \tabs{\alpha}{\abs{x}{t}}$.  Then we have:
  \begin{itemize}
  \item $\interpret{u} =
    \tabs{\xi}{\abs{y:\quant{\alpha}{\sigma \arrtype \xi}}{
    y * \typeinterpret{\tau} \cdot \interpret{s}}}$ (which has type
    $\quant{\xi}{\quant{\alpha}{\sigma \arrtype \xi} \arrtype \xi}$);
  \item $\interpret{w} = \tabs{\alpha}{\abs{x:\typeinterpret{\sigma}}{
    \interpret{t}}}$ (which has type $\quant{\alpha}{\sigma \arrtype
    \rho}$ with $\alpha \notin \FTV(\rho)$);
  \item $\interpret{\mathtt{let}_{\quant{\alpha}{\sigma},\rho}(u,w)} =
    \interpret{u} * \rho \cdot \interpret{w} \oplus
    \lift(\flatten(\interpret{w})\oplus 1) \succeq
    \interpret{u} * \rho \cdot \interpret{w} \oplus \lift(1)$ by
    Lemmas \ref{lem:liftgreater} and \ref{lem:plustimesmonotonic} as
    before; by Lemma \ref{lem:plustimesmonotonic} again this term
    $\succ \interpret{u} * \rho \cdot \interpret{w}
    \leadsto (\abs{y}{y * \typeinterpret{\tau} \cdot \interpret{s}})
    \cdot \interpret{w} \leadsto \interpret{w} * \typeinterpret{\tau}
    \cdot \interpret{s} \leadsto (\abs{x:\typeinterpret{\sigma}[\alpha:=
    \typeinterpret{\tau}]}{\interpret{t}[\alpha:=\typeinterpret{\tau}]})
    \cdot \interpret{s} \leadsto \interpret{t}[\alpha:=\typeinterpret{
    \tau}][x:=\interpret{s}]$.  By Lemma
    \ref{lem:substitutioninterpret} this is equal to
    $\interpret{t[\alpha:=\tau][x:=s]}$.
  \end{itemize}
\item $\pi^1_{\sigma,\tau}(\mathtt{pair}_{\sigma,\tau}(s,t)) \leadsto
  s$ \\
  We have $\interpret{\pi^1_{\sigma,\tau}(\mathtt{pair}_{\sigma,\tau}(
  s,t))} = \pi^1_{\typeinterpret{\sigma,\tau}}(\interpret{s},
  \interpret{t}) \oplus \lift(1) \leadsto \interpret{s} \oplus
  \lift(1) \succ \interpret{s}$.
\item $\pi^2_{\sigma,\tau}(\mathtt{pair}_{\sigma,\tau}(s,t)) \red t$ \\
  We have $\interpret{\pi^2_{\sigma,\tau}(\mathtt{pair}_{\sigma,\tau}(
 s,t))} = \pi^2_{\typeinterpret{\sigma,\tau}}(\interpret{s},
  \interpret{t}) \oplus \lift(1) \leadsto \cdot \succ \interpret{t}$.
\item $\mathtt{case}_{\sigma,\tau,\rho}(\mathtt{in}^1_{\sigma,\tau}(u),
  \abs{x}{s},\abs{y}{t}) \red s[x:=u]$ \\
  For brevity, let $uu := \interpret{\mathtt{in}^1_{\sigma,\tau}(u)} =
  (\interpret{u}, \lift_\tau(1))$.
  Also denote $\varphi := \lift_\rho(\flatten_{\sigma \times \tau}(
  uu) \oplus_{\nat} 1)$. \\
  We have $\interpret{\mathtt{case}_{\sigma,\tau,\rho}(\dots)} =
  \lift_\rho(37) \oplus (\varphi\,\otimes (\ (\abs{x:
  \typeinterpret{\sigma}}{\interpret{s}}) \cdot \proj^1_{\sigma,\tau}(
  uu) \oplus
  (\abs{y:\typeinterpret{\tau}}{\interpret{t}}) \cdot \proj^2_{\sigma,
  \tau}(uu)\ \oplus \lift(1)))$.
  Note that $\varphi \succeq \lift_\rho(1)$ by
  Lemma \ref{lem:liftgreater}.  Therefore, by monotonicity of $\oplus$
  and $\otimes$, the distribution property (Lemmas
  \ref{lem:plustimesmonotonic} and
  \ref{lem:approxproperties}(\ref{lem:approx:distribution})), this
  term $\succeq \lift(37) \oplus (\abs{x}{\interpret{s}}) \cdot
  \proj^1_{\sigma,\tau}(uu) \oplus (\abs{y}{\interpret{t}}) \cdot
  \proj^2_{\sigma,\tau}(uu) \oplus \lift(1) \leadsto^* \lift(37) \oplus
  \interpret{s}[x:=\interpret{u}] \oplus
  \interpret{t}[y:=\interpret{u}] \oplus \lift(1)$.  By Lemma
  \ref{lem:plusparts}\footnote{\CK{Since Lemma
  \ref{lem:plusparts} only gives that $s \oplus \lift(n) \succ s$ and
  not $\lift(n) \oplus s \succ s$, I use Lemma
  \ref{lem:approxproperties}(\ref{lem:approx:symmetry}) to obtain
  $\lift(n) \oplus s \succeq s \oplus \lift(n) \succ s$.  We will
  then also need an \emph{extended version} of Lemma
  \ref{lem:compatibility}, since as is, it does not state that
  $\succeq \cdot \succ$ is included in $\succ$.}}, this term
  $\succ \interpret{s}[x:=\interpret{u}] = \interpret{s[x:=u]}$ by
  Lemma \ref{lem:substitutioninterpret}.
\item $\mathtt{case}_{\sigma,\tau,\rho}(\mathtt{in}^2_{\sigma,\tau}(u),
  \abs{x}{s},\abs{y}{t}) \red t[x:=u]$ \\
  Symmetric to the case above.
\item $
\mathtt{case}_{\rho,\pi,\xi}(\mathtt{case}_{\sigma,\tau,\mathtt{or}(
  \rho,\pi)}(u,\abs{x}{s},\abs{y}{t}),\abs{z}{v},\abs{a}{w}) %& \red &
  \red\\
  \mathtt{case}_{\sigma,\tau,\xi}(u,
    \abs{x}{\mathtt{case}_{\rho,\pi,\xi}(s,\abs{z}{v},\abs{a}{w})},
    \abs{y}{\mathtt{case}_{\rho,\pi,\xi}(t,\abs{z}{v},\abs{a}{w})}) $\\
  We have:
  \begin{itemize}
  \item $aa := \interpret{\mathtt{case}_{\sigma,\tau,\mathtt{or}(\rho,
    \pi)}(u,\abs{x}{s},\abs{y}{t})} =$\\$
    \lift_{\typeinterpret{\rho} \times \typeinterpret{\pi}}(37) \oplus
    (\ \lift_{\typeinterpret{\rho} \times \typeinterpret{\pi}}(
      \flatten_{\typeinterpret{\sigma} \times \typeinterpret{\tau}}(
        \interpret{u}) \oplus 1) \otimes$ \\
    \phantom{x} \hfill
    $(\ ((\abs{x}{\interpret{s}}) \cdot \proj^1(\interpret{u})) \oplus
    ((\abs{y}{\interpret{t}}) \cdot \proj^2(\interpret{u})) \oplus
    \lift(1)\ )\ )$
  \end{itemize}
\end{itemize}

==========================

\[
\begin{array}{rcl}
\epsilon_\tau(\epsilon_\bot(s)) & \red & \epsilon_\tau(s) \\
@_{\sigma,\tau}(\epsilon_{\sigma \arrtype \tau}(s),t) & \red &
  \epsilon_\tau(s) \\
\mathtt{tapp}_{\quant{\alpha}{\sigma},\tau}(
  \epsilon_{\quant{\alpha}{\sigma}}(s)) & \red &
  \epsilon_{\sigma[\alpha:=\tau]}(s) \\
\pi^1_{\sigma,\tau}(\epsilon_{\mathtt{and}(\sigma,\tau)}(s)) & \red &
  \epsilon_\sigma(s) \\
\pi^2_{\sigma,\tau}(\epsilon_{\mathtt{and}(\sigma,\tau)}(s)) & \red &
  \epsilon_\tau(s) \\
\mathtt{case}_{\sigma,\tau,\rho}(\epsilon_{\mathtt{or}(\sigma,\tau)}(
  u),\abs{x}{s},\abs{y}{t}) & \red & \epsilon_\rho(s) \\
\mathtt{let}_{\qquant{\forall}{\alpha}{\sigma},\rho}(\epsilon_{\qquant{
  \forall}{\alpha}{\sigma}}(s),\tabs{\alpha}{\abs{x}{t}}) & \red &
  \epsilon_\rho(s) \\
\end{array}
\]

\begin{itemize}
%\[
%\begin{array}{rcl}
\item $
\epsilon_\rho(\mathtt{case}_{\sigma,\tau,\bot}(u,\abs{x}{s},\abs{y}{t}))
  %& \red &
  \red
  \mathtt{case}_{\sigma,\tau,\rho}(u,\abs{x}{\epsilon_\rho(s)},
  \abs{y}{\epsilon_\rho(t)}) $%\\
\item $
@_{\rho,\pi}(\mathtt{case}_{\sigma,\tau,\rho \arrtype \pi}(u,
  \abs{x}{s},\abs{y}{t}),v) %& \red &
  \red
  \mathtt{case}_{\sigma,\tau,\pi}(u,
  \abs{x}{@_{\rho,\pi}(s,v)},\abs{y}{@_{\rho,\pi}(t,v)}) $%\\
\item $
\mathtt{tapp}_{\quant{\alpha}{\rho},\pi}(\mathtt{case}_{\sigma,\tau,
  \quant{\alpha}{\rho}}(u,\abs{x}{s},\abs{y}{t})) %& \red &
  \red
  \mathtt{case}_{\sigma,\tau,\rho[\alpha:=\pi]}(u,
  \abs{x}{\mathtt{tapp}_{\quant{\alpha}{\rho},\pi}(s)},\\
  \abs{y}{\mathtt{tapp}_{\quant{\alpha}{\rho},\pi}(t)}) $%\\
\item $
\pi^1_{\rho,\pi}(\mathtt{case}_{\sigma,\tau,\mathtt{and}(\rho,\pi)}(u,
  \abs{x}{s},\abs{y}{t})) %& \red &
  \red
  \mathtt{case}_{\sigma,\tau,\rho}(u,\abs{x}{\pi^1_{\rho,\pi}(s)},
  \abs{y}{\pi^1_{\rho,\pi}(t)}) $%\\
\item $
\pi^2_{\rho,\pi}(\mathtt{case}_{\sigma,\tau,\mathtt{and}(\rho,\pi)}(u,
  \abs{x}{s},\abs{y}{t})) %& \red &
  \red
  \mathtt{case}_{\sigma,\tau,\pi}(u,\abs{x}{\pi^2_{\rho,\pi}(s)},
  \abs{y}{\pi^2_{\rho,\pi}(t)}) $%\\
\item $
\mathtt{let}_{\qquant{\forall}{\alpha}{\rho}}(
  \mathtt{case}_{\sigma,\tau,\qquant{\forall}{\alpha}{\rho}}(
  u,\abs{x}{s},\abs{y}{t}),v) %& \red &
  \red\\
  \mathtt{case}_{\sigma,\tau,\rho}(u,
  \abs{x}{\mathtt{let}_{\qquant{\forall}{\alpha}{\rho}}(s,v)},
  \abs{y}{\mathtt{let}_{\qquant{\forall}{\alpha}{\rho}}(t,v)})
  $%\\
%\end{array}
%\]
\end{itemize}
\begin{itemize}
\item $\epsilon_\tau(\mathtt{let}_{\qquant{\forall}{\alpha}{\sigma},
  \bot}(s,t)) \red
  \mathtt{let}_{\qquant{\forall}{\alpha}{\sigma},\tau}(s,\epsilon_\tau(t))$
\item $@_{\tau,\rho}(\mathtt{let}_{\qquant{\forall}{\alpha}{\sigma},
  \tau \arrtype \rho}(s,t),u) \red
  \mathtt{let}_{\qquant{\forall}{\alpha}{\sigma},\rho}(s,@_{\tau,\rho}(t,
  u))$
\item $\mathtt{tapp}_{\quant{\alpha}{\tau},\rho}(
\mathtt{let}_{\qquant{\forall}{\alpha}{\sigma},\quant{\alpha}{\tau}}(s,t))
  \red
  \mathtt{let}_{\qquant{\forall}{\alpha}{\sigma},\tau[\alpha:=\rho]}(s,
  \mathtt{tapp}_{\quant{\alpha}{\tau},\rho}(t))$
\item $\pi^1_{\tau,\rho}(\mathtt{let}_{\qquant{\forall}{\alpha}{\sigma},
  \mathtt{and}(\tau,\rho)}(s,t)) \red
  \mathtt{let}_{\qquant{\forall}{\alpha}{\sigma},\tau}(s,\pi^1_{\tau,
  \rho}(t))$
\item $\pi^2_{\tau,\rho}(\mathtt{let}_{\qquant{\forall}{\alpha}{\sigma},
  \mathtt{and}(\tau,\rho)}(s,t)) \red
  \mathtt{let}_{\qquant{\forall}{\alpha}{\sigma},\rho}(s,\pi^2_{\tau,
  \rho}(t))$
\item $\mathtt{case}_{\tau,\rho,\pi}(
  \mathtt{let}_{\qquant{\forall}{\alpha}{\sigma},\mathtt{or}(\tau,
  \rho)}(s,t),\abs{x}{u},\abs{y}{v}) \red
  \mathtt{let}_{\qquant{\forall}{\alpha}{\sigma},\pi}(s,\mathtt{case}_{
  \tau,\rho,\pi}(t,\abs{x}{u},\abs{y}{v}))$
\item $\mathtt{let}_{\qquant{\forall}{\beta}{\tau},\rho}(\mathtt{let}_{\qquant{\forall}{\alpha}{\sigma},\qquant{\forall}{\beta}{\tau}}(s,t),u) \red
  \mathtt{let}_{\qquant{\forall}{\alpha}{\sigma},\rho}(s,\mathtt{let}_{\qquant{\forall}{\beta}{\tau},\rho}(t,u))$
\end{itemize}
\end{document}
