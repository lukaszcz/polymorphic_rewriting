\documentclass[10pt,presentation,color=names]{beamer}
\usepackage{etex}
\usetheme{boxes}

\setbeamertemplate{caption}[numbered]
\setbeamertemplate{caption label separator}{: }
\setbeamercolor{caption name}{fg=normal text.fg}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{itemize items}{$\cdot$}
\setbeamertemplate{footline}[frame number]

\usepackage[all]{xy}
\usepackage{proof}

\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{stmaryrd}
\usepackage{latexsym} % for nicer \leadsto
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english]{babel}

\usefonttheme{professionalfonts}
\renewcommand{\sfdefault}{\rmdefault}

\newcommand{\Fomega}{\mathtt{F}_\omega}

\newcommand{\Typevars}{\mathcal{A}}
\newcommand{\Vars}{\mathcal{V}}
\newcommand{\Rules}{\mathcal{R}}
\newcommand{\Iterms}{\mathcal{I}}
\newcommand{\ITypes}{\mathcal{Y}}

\newcommand{\arrkind}{\Rightarrow}
\newcommand{\arrtype}{\rightarrow}
\newcommand{\quant}[2]{\forall #1.#2}

\newcommand{\abstraction}[2]{\backslash #1.#2}
\newcommand{\app}[2]{#1 \cdot #2}
\newcommand{\tapp}[2]{#1 * #2}
\newcommand{\subst}[2]{#1:=#2}

\newcommand{\abs}[2]{\lambda #1.#2}
\newcommand{\tabs}[2]{\Lambda #1.#2}
\newcommand{\pair}[2]{\langle #1,#2 \rangle}
\newcommand{\expair}[2]{[#1,#2]}

\newcommand{\arrW}{\leadsto}
\newcommand{\arr}[1]{\longrightarrow_{#1}}
\newcommand{\red}{\longrightarrow}
\newcommand{\arrrbeta}{\arrW_\beta^*}

\newcommand{\nat}{\mathtt{nat}}
\newcommand{\flatten}{\mathtt{flatten}}
\newcommand{\lift}{\mathtt{lift}}

\newcommand{\typeinterpret}[1]{\llbracket #1 \rrbracket}
\newcommand{\interpret}[1]{\llbracket #1 \rrbracket}
\newcommand{\itp}[1]{\llbracket #1 \rrbracket}

\newcommand{\refsec}[1]{Section~\ref{sec:#1}}

\newcommand{\FTV}{\mathrm{FTV}}
\newcommand{\FV}{\mathrm{FV}}
\newcommand{\Tc}{\mathcal{T}}
\newcommand{\Vc}{\mathcal{V}}
\newcommand{\Xc}{\mathcal{X}}

\newcommand{\cl}{\mathcal{C}}
\newcommand{\dom}{\mathrm{dom}}
\newcommand{\nf}{\mathrm{nf}}

\newcommand{\da}{\mathord{\downarrow}}
\newcommand{\SN}{\mathrm{SN}}
\newcommand{\Cb}{\mathbb{C}}
\newcommand{\Nbb}{\mathbb{N}}
\newcommand{\val}[3]{\ensuremath{\llbracket#1\rrbracket_{#2}^{#3}}}
\newcommand{\gteq}[3]{\ensuremath{\ge_{#1}^{#2,#3}}}

\newcommand{\Typemap}{\mathcal{T\!M}}
\newcommand{\Termmap}{\mathcal{J}}
\newcommand{\succinterpret}{\succ^{\Termmap}}
\newcommand{\succeqinterpret}{\succeq^{\Termmap}}

\newcommand{\symb}[1]{\textcolor{blue}{\mathtt{#1}}}
\newcommand{\var}[1]{\textcolor{red}{#1}}
\newcommand{\binder}[1]{\textcolor{purple}{#1}}

\newcommand{\List}{\mathtt{List}}
\newcommand{\Pair}{\mathtt{Pair}}
\newcommand{\Nat}{\mathtt{Nat}}
\newcommand{\nil}{\symb{nil}}
\newcommand{\cons}{\symb{cons}}
\newcommand{\map}{\symb{map}}
\newcommand{\fold}{\symb{fold}}
\newcommand{\xlet}[4]{\mathtt{let}_{#1}\,#2\,\mathtt{be}\,[#3]\,\mathtt{in}\,#4}
\newcommand{\proj}{\symb{pr}}

\title{Polymorphic Higher-order Termination}

\author{\L{}ukasz Czajka, TU Dortmund University\\Cynthia Kop, Radboud University Nijmegen}

\date{June 2019}

\begin{document}
\maketitle

\begin{frame}{Polynomial interpretations: first-order}

%STORY: talk about TRSs and what we mean by termination .
%STORY: introduce polynomial interpretations as one of the oldest techniques to prove it.
%STORY: discuss on a high level how the interpretation given here works.

\textbf{Question:} Does the following TRS terminate?
\[
\begin{array}{rcl}
\symb{append}(\nil, \var{ys}) & \red & \var{ys} \\
\symb{append}(\cons(\var{x},\var{xs}),\var{ys}) & \red & \cons(\var{x},\symb{append}(\var{xs},\var{ys})) \\
\end{array}
\]

\ \\\pause
\textbf{Answer:} Yes, it does. \pause
Let:
\[
\begin{array}{rcl}
\interpret{\nil} & = & 1 \\
\interpret{\cons}(s,t) & = & 1 + \interpret{s} + \interpret{t} \\
\interpret{\symb{append}}(s,t) & = & 2 * \interpret{s} + \interpret{t} \\
\end{array}
\]
\pause Then:
\[
\begin{array}{rcl}
\interpret{\symb{append}(\nil, \var{ys})} & = & 2 + \var{ys} \\
  & > & \var{ys} \\
  & = & \interpret{\var{ys}} \\\
\interpret{\symb{append}(\cons(\var{x},\var{xs}),\var{ys})} & = & 2 + 2\var{x} + 2\var{xs} + ys \\
  & > & 1 + \var{x} + 2\var{xs} + \var{ys} \\
  & = & \interpret{\cons(\var{x},\symb{append}(\var{xs},\var{ys}))} \\
\end{array}
\]
\end{frame}

%CK: Note that I chose map rather than fold because there is no polynomial interpretation for
%    monomorphic fold -- at least, not in the earlier definitions. There may be one with our
%    definitions; that I do not know.
\begin{frame}{Polynomial interpretations: higher-order}

\textbf{Question:} Does the following higher-order TRS terminate?
\[
\begin{array}{rcl}
\map(\var{F},\nil) & \red & \nil \\
\map(\var{F},\cons(\var{x},\var{xs})) & \red & \cons(\var{F} \cdot \var{x},\map(\var{F},\var{xs})) \\
\end{array}
\]

\ \\\pause
\textbf{Answer:} Depends. \pause
%STORY: Would it surprise you if I told you that this might actually be non-terminating?
\alert{Not} terminating if:
\[
\begin{array}{rcl}
\nil & : & \mathtt{o} \\
\cons & : & (\mathtt{o} \arrtype \mathtt{o}) \arrtype \mathtt{o} \arrtype \mathtt{o} \\
\map & : & ((\mathtt{o} \arrtype \mathtt{o}) \arrtype \mathtt{o}) \arrtype \mathtt{o} \arrtype \mathtt{o} \\
\end{array}
\]

%STORY: Types are important; especially when you have lambda-abstraction, you have to be careful. With the given typing, the rules above can be used to encode the untyped lambda-calculus. This is exemplified by the following non-terminating term.
%NOTE: This would be told very quickly, to show to the RTA crowd why types are important; however, I do not want to waste too much time on it as it's not the point of the talk.
%It's not the point of this talk, after all -- but does help to illustrate to the RTA part of the audience why we look at types so much.
\ \\\pause
Let $\omega := \cons(\abs{\binder{x}:o}{\map(\abs{\binder{y}:\mathtt{o} \arrtype \mathtt{o}}{\binder{y}\ \binder{x}},\binder{x})},\nil)$. Then:
\[
\begin{array}{ll}
& \map(\abs{\binder{y}:\mathtt{o} \arrtype \mathtt{o}}{\binder{y}\ \omega},\omega) \\
\red & \cons(\ (\abs{\binder{y}:\mathtt{o} \arrtype \mathtt{o}}{\binder{y}\ \omega})\ 
  (\abs{\binder{x}:o}{\map(\abs{\binder{y}:\mathtt{o} \arrtype \mathtt{o}}{\binder{y}\ \binder{x}},\binder{x})})\ , \map(\dots)) \\
\red_\beta & \cons(\ (\abs{\binder{x}:o}{\map(\abs{\binder{y}:\mathtt{o} \arrtype \mathtt{o}}{\binder{y}\ \binder{x}},\binder{x})})\ \omega\ , \map(\dots)) \\
\red_\beta & \cons(\ \underline{\map(\abs{\binder{y}:\mathtt{o} \arrtype \mathtt{o}}{\binder{y}\ \omega},\omega)}\ , \map(\dots)) \\
\end{array}
\]
\ \\
\ \\
\ \\
\ \\
\ \\
\ \\
\end{frame}

\begin{frame}{Polynomial interpretations: higher-order}

%STORY: If the types work out, we can try to use the same idea for higher-order rewriting, as seen for instance in functional programming and various proof systems.
%STORY: Here give a very rough sketch of Jaco's work.

\textbf{Question:} Does the following higher-order TRS terminate?
\[
\begin{array}{rcl}
\map(\var{F},\nil) & \red & \nil \\
\map(\var{F},\cons(\var{x},\var{xs})) & \red & \cons(\var{F} \cdot \var{x},\map(\var{F},\var{xs})) \\
\end{array}
\]

\ \\
\textbf{Answer:} Depends. \pause It \alert{does} terminate if:
\[
\begin{array}{rcl}
\nil & : & \List \\
\cons & : & \Nat \arrtype \List \arrtype \List \\
\map & : & (\Nat \arrtype \Nat) \arrtype \List \arrtype \List \\
\end{array}
\]

\pause Let:
\[
\begin{array}{rcl}
\interpret{\nil} & = & 0 \\
\interpret{\cons(s,t)} & = & 1 + \interpret{s} + \interpret{t} \\
\interpret{\map(s,t)} & = & (2 + \interpret{t}) * (1 + \interpret{s}(\interpret{t})) \\
\interpret{s\ t} & = & \interpret{s}(\interpret{t}) + \interpret{t}\ \ \text{if}\ s : \Nat \arrtype \Nat \\
\end{array}
\]

\pause Then:
\[
\begin{array}{rcl}
\interpret{\map(\var{F},\nil)} & = & \var{F}(0) + 1 \\
 & > & 0 = \interpret{\nil} \\
\interpret{\map(\var{F},\cons(\var{x},\var{xs}))} & = &
  (2 + \var{F}(1 + \var{x} + \var{xs})) * (2 + \var{x} + \var{xs}) \\
  & > & 1 + \var{F}(\var{x}) + \var{x} + (2 + \var{xs}) * (1 + \var{F}(\var{xs})) \\
  & = & \interpret{\cons(\var{F} \cdot \var{x},\map(\var{F},\var{xs}))} \\
\end{array}
\]

\end{frame}

\begin{frame}{Polynomial interpretations: polymorphic higher-order}

%STORY: Let's take this a step further and go for a polymorphic system. This is the kind of polymorphism that we see in ML-like language.

\textbf{Question:} Does the following polymorphic HO-TRS terminate?
\[
\begin{array}{rcl}
\map(\var{F},\nil) & \red & \nil \\
\map(\var{F},\cons(\var{x},\var{xs})) & \red & \cons(\var{F} \cdot \var{x},\map(\var{F},\var{xs})) \\
\end{array}
\]
\[
\begin{array}{rcll}
\nil & : & \forall \alpha. & \List(\alpha) \\
\cons & : & \forall \alpha. & \alpha \arrtype \List(\alpha) \arrtype \List(\alpha) \\
\map & : & \forall \alpha \beta. & (\alpha \arrtype \beta) \arrtype \List(\alpha) \arrtype \List(\beta) \\
\end{array}
\]

%STORY: Now, it actually is terminating, and we could see that by considering all possible type instances. Let's look at another example.
\pause\ \\
\textbf{Question:} What about the following?
\[
\begin{array}{rcl}
\fold(\var{F},\var{a},\nil) & \red & \var{a} \\
\fold(\var{F},\var{a},\cons(\var{x},\var{xs})) & \red & \fold(\var{F},\var{F}\ \var{a}\ \var{x},\var{xs})
\end{array}
\]
\[
\begin{array}{rcll}
\fold & : & \forall \alpha \beta . & (\beta \arrtype \alpha \arrtype \beta) \arrtype \beta \arrtype \List(\alpha) \arrtype \beta \\
\end{array}
\]
%STORY: Note that this example is somewhat different than map, because a functional variable is applied repeatedly on the same item; that is, you build a term like F^n(x).
%STORY: This cannot be handled with the "higher-order polynomial" interpretations from the last slide, although arguably that's just a weakness of that definition of polynomials.
\end{frame}

\begin{frame}{Shallow vs.\ Higher-rank impredicative polymorphism}
\textbf{Shallow polymorphism:}
\[
\begin{array}{rcllr}
\uncover<2->{\List} & \uncover<2->{:} & \multicolumn{2}{l}{\uncover<2->{* \arrtype *}} & \uncover<2>{\alert{\Longleftarrow}} \\
\nil & : & \forall \alpha. & \List(\alpha) \\
\cons & : & \forall \alpha. & \alpha \arrtype \List(\alpha) \arrtype \List(\alpha) \\
\fold & : & \forall \alpha \beta . & (\beta \arrtype \alpha \arrtype \beta) \arrtype \beta \arrtype \List(\alpha) \arrtype \beta \\
\end{array}
\]
\[
\begin{array}{rclr}
\fold_{\only<2->{\tau,\sigma}}(\var{F},\var{a},\nil_{\only<2->{\tau}}) & \red & \var{a} & \uncover<2>{\alert{\Longleftarrow}} \\
\fold_{\only<2->{\tau,\sigma}}(\var{F},\var{a},\cons_{\only<2->{\tau}}(\var{x},\var{xs})) & \red
  & \fold_{\only<2->{\tau,\sigma}}(\var{F},\var{F}\ \var{a}\ \var{x},\var{xs}) & \uncover<2>{\alert{\Longleftarrow}} \\
\end{array}
\]

\pause\pause\ \\
\textbf{Higher-rank impredicative polymorphism}
\[
\begin{array}{rcllr}
\List & : & & * \\
\nil & : & & \List \\
\cons & : & \forall \alpha. & \alpha \arrtype \List \arrtype \List \\
\fold & : & \forall \beta . & (\forall \alpha . \beta \arrtype \alpha \arrtype \beta) \arrtype \beta \arrtype \List \arrtype \beta \\
\end{array}
\]
\[
\begin{array}{rclr}
\fold_{\sigma}(\var{F},\var{a},\nil) & \red & \var{a} & \uncover<2>{\alert{\Longleftarrow}} \\
\fold_{\sigma}(\var{F},\var{a},\cons_{\tau}(\var{x},\var{xs})) & \red & \fold_{\sigma}(\var{F},\var{F}\ \tau\ \var{a}\ \var{x},\var{xs}) \\
\end{array}
\]

%STORY: Here make sure to discuss the application domains: Haskell, logic.
\end{frame}

\begin{frame}{Our goal: handle systems like this!}
\framesubtitle{Polymorphic functional systems}

%STORY: There are many ways to formalise systems like this; we use the following because it's convenient:
\begin{itemize}
\item Function symbols have a type: $\forall \alpha_1 \dots \alpha_n.\sigma_1 \arrtype \dots \arrtype \sigma_k \arrtype \tau$
\item Terms are variables, abstractions, type abstractions and: $\symb{f}_{\pi_1,\dots,\pi_n}(s_1,\dots,s_k) : \tau[\alpha_1:=\pi_1,\dots,\alpha_n:=\pi_n]$.
  \pause
%STORY: Okay, so what does this mean for the fold system that we just saw?
%STORY: (before the first pause) This is what we had, but note that we have those applications there.
%STORY: (before the second pause) So, we introduce function symbols for application and type application, and corresponding rules.
%STORY: (before the third pause) Then, we replace the applications and type applications accordingly.
\[
\begin{array}{rcllrl}
\List & : & & * \\
\nil & : & & \List \\
\cons & : & \forall \alpha. & \alpha \arrtype \List \arrtype \List \\
\fold & : & \forall \beta . & (\forall \alpha . \beta \arrtype \alpha \arrtype \beta) \arrtype \beta \arrtype \List \arrtype \beta \\
\uncover<3->{\symb{@}} & \uncover<3->{:} & \uncover<3->{\forall \alpha\forall \beta. & (\alpha \arrtype \beta) \arrtype (\alpha \arrtype \beta)} &
  \uncover<3->{\alert{\Longleftarrow}} \\
\uncover<3->{\symb{tapp}} & \uncover<3->{:} & \uncover<3->{\forall \alpha : * \arrkind *.\forall \beta.} & \uncover<3->{(\forall \gamma.\alpha\gamma) \arrtype \alpha\beta} &
  \uncover<3->{\alert{\Longleftarrow}} \\
\end{array}
\]
\[
\begin{array}{rcll}
\fold_{\sigma}(\var{F},\var{a},\nil) & \red & \var{a} \\
\fold_{\sigma}(\var{F},\var{a},\cons_{\tau}(\var{x},\var{xs})) & \red & \uncover<1-3>{\fold_{\sigma}(\var{F},\var{F}\ \tau\ \var{a}\ \var{x},\var{xs})} \\
  \multicolumn{4}{r}{\uncover<4->{
    \fold_{\sigma}(\var{F},\symb{@}_{\tau,\sigma}(\symb{@}_{\sigma,\tau \arrtype \sigma}(\symb{tapp}_{\lambda \alpha.\sigma \arrtype \alpha \arrtype \sigma,\tau}(\var{F}), \var{a}), \var{x}),\var{xs})
  }} \\
\uncover<3->{\symb{@}_{\sigma,\tau}(\abs{x:\sigma.s},t)} & \uncover<3->{\red} & \uncover<3->{s[x:=t]} &
  \uncover<3->{\alert{\Longleftarrow}} \\
\uncover<3->{\symb{tapp}_{\lambda \alpha.\sigma,\tau}(\tabs{\alpha}{s})} & \uncover<3->{\red} & \uncover<3->{s[\alpha:=\tau]} &
  \uncover<3->{\alert{\Longleftarrow}} \\
\end{array}
\]
%STORY: This is not a natural formalism. It doesn't need to be: it is just meant to define the method. Real polymorphic systems would be translated into it.
\item\pause\pause\pause \textbf{\alert{Note:} not meant as a formalism of interest by itself, but only as a tool to analyse polymorphic systems.}
\end{itemize}
\end{frame}

%=================================================


\begin{frame}{Polynomial interpretations: polymorphic higher-order}
  \framesubtitle{Shallow polymorphism: homogeneous fold}
  \[
  \begin{array}{l}
    \List : * \red * \\
    \mathtt{nil} : \forall \alpha . \List(\alpha) \\
    \mathtt{cons} : \forall \alpha . \alpha \arrtype \List(\alpha) \arrtype \List(\alpha) \quad\quad \\
    \mathtt{foldl} : \forall \alpha \beta . (\beta \arrtype \alpha \arrtype \beta) \arrtype \beta \arrtype \List(\alpha) \arrtype \beta \\
    \mathtt{foldl}_{\tau,\sigma}(f,a,\nil_\tau) \red a \\
    \mathtt{foldl}_{\tau,\sigma}(f,a,\cons_\tau(x,l)) \red \mathtt{foldl}_{\tau,\sigma}(f,f a x,l)
  \end{array}
  \]
\end{frame}

\begin{frame}{Polynomial interpretations: polymorphic higher-order}
  \framesubtitle{Higher-rank impredicative polymorphism: heterogeneous fold}
  \[
  \begin{array}{l}
    \List : * \\
    \mathtt{nil} : \List \\
    \mathtt{cons} : \forall \alpha . \alpha \arrtype \List \arrtype \List \quad\quad \\
    \mathtt{foldl} : \forall \beta . (\forall \alpha . \beta \arrtype \alpha \arrtype \beta) \arrtype \beta \arrtype \List \arrtype \beta \\
    \mathtt{foldl}_\sigma(f,a,\nil) \red a \\
    \mathtt{foldl}_\sigma(f,a,\cons_\tau(x,l)) \red \mathtt{foldl}_\sigma(f,f \tau a x,l)
  \end{array}
  \]
\end{frame}

\begin{frame}{Polynomial interpretations: polymorphic higher-order}
  \framesubtitle{Heterogeneous fold as a Polymorphic Functional System}
  Function symbols:
  \[
  \begin{array}{rcl}
    @ & : & \forall \alpha \forall \beta . (\alpha \arrtype \beta) \arrtype \alpha \arrtype \beta \\
    \mathtt{A} & : & \forall \alpha : * \arrkind * . \forall \beta .
    (\forall \gamma .\alpha \gamma) \arrtype \alpha \beta \\
    \mathtt{nil} & : & \List \\
    \mathtt{cons} & : & \forall \alpha . \alpha \arrtype \List \arrtype \List \\
    \mathtt{foldl} & : & \forall \beta . (\forall \alpha . \beta \arrtype \alpha \arrtype \beta) \arrtype \beta \arrtype \List \arrtype \beta
  \end{array}
  \]\pause
  Rules:
  \[
  \begin{array}{rcl}
    @_{\sigma,\tau}(\abs{x:\sigma}{s},t) & \red & s[x:=t] \\
    \mathtt{A}_{\abs{\alpha}{\sigma},\tau}(\tabs{\alpha}{s}) & \red & s[\alpha:=\tau] \\
    \mathtt{foldl}_\sigma(f,s,\nil) & \red & s \\
    \mathtt{foldl}_\sigma(f,s,\cons_\tau(h,t)) & \red & \\
    \multicolumn{3}{c}{\quad\quad\mathtt{foldl}_\sigma(f,@_{\tau,\sigma}(@_{\sigma,\tau\arrtype\sigma}(\mathtt{A}_{\abs{\alpha}{\sigma\arrtype\alpha\arrtype\sigma},\tau}(f),s),h),t)}
  \end{array}
  \]
\end{frame}

\begin{frame}{Polynomial interpretations: polymorphic higher-order}
  \framesubtitle{Interpretation terms: extension of system~$\Fomega$}
  Type constructors:
  \[
  \begin{array}{rcl}
    \Tc_{*} &::=& \Vc_{*} \mid \Sigma^T_{*} \mid \Tc_{\kappa\arrkind
      *}\Tc_{\kappa} \mid \forall\Vc_\kappa\Tc_* \mid
    \Tc_*\arrtype\Tc_* \\ \Tc_{\kappa_1\arrkind\kappa_2} &::=&
    \Vc_{\kappa_1\arrkind\kappa_2} \mid
    \Sigma^T_{\kappa_1\arrkind\kappa_2} \mid
    \Tc_{\kappa\arrkind(\kappa_1\arrkind\kappa_2)}\Tc_{\kappa} \mid
    \lambda \Vc_{\kappa_1} \Tc_{\kappa_2}
  \end{array}
  \]
  \pause
  \begin{example}
  If $\Sigma^T_{*} = \{ \List \}$ and $\Sigma^T_{* \arrkind * \arrkind
    *} = \{ \Pair \}$, types are for instance $\List$ and $\forall
  \alpha.\Pair\,\alpha\,\List$.  The expression $\Pair\,\List$ is a
  type constructor, but not a type.  If $\Sigma^T_{(* \arrkind *)
    \arrkind *} = \{ \exists \}$ and $\sigma \in \Tc_{* \arrkind *}$,
  then both $\exists(\sigma)$ and $\exists (\lambda
  \alpha.\sigma\alpha)$ are types.
  \end{example}
\end{frame}

\begin{frame}{Polynomial interpretations: polymorphic higher-order}
  \framesubtitle{Interpretation terms: extension of system~$\Fomega$}
  Terms:
  \begin{itemize}
  \item $x : \sigma$ for $(x : \sigma) \in \Vars$.
  \item $\mathtt{f} : \sigma$ for all
    $(\mathtt{f} : \sigma) \in \Sigma$.
  \item $\abs{x:\sigma}{s} : \sigma \arrtype \tau$ if
    $(x : \sigma) \in \Vars$ and $s : \tau$.
  \item $(\tabs{\alpha:\kappa}{s}) : (\quant{\alpha:\kappa}{\sigma})$ if
    $s : \sigma$ and $\alpha$ does not occur free in the type of a
    free variable of~$s$.
  \item $\app{s}{t} : \tau$ if $s : \sigma \arrtype \tau$ and
    $t : \sigma$
  \item $\tapp{s}{\tau} : \sigma[\subst{\alpha}{\tau}]$ if
    $s : \quant{\alpha:\kappa}{\sigma}$ and~$\tau$ is a type
    constructor of kind~$\kappa$,
  \item $s : \tau$ if $s : \tau'$ and $\tau =_\beta \tau'$.
  \end{itemize}
  \pause
  Signature: $\Sigma^T = \{ \nat : * \}$ and $\Sigma = \{ n : \nat
  \mid n \in \Nbb \} \cup \Sigma_f$, where $\Sigma_f = \{ \oplus :
  \forall \alpha . \alpha \arrtype \alpha \arrtype \alpha, \otimes :
  \forall \alpha . \alpha \arrtype \alpha \arrtype \alpha, \flatten :
  \forall \alpha . \alpha \arrtype \nat, \lift : \forall \alpha . \nat
  \arrtype \alpha \}$.
\end{frame}

\begin{frame}{Polynomial interpretations: polymorphic higher-order}
  \framesubtitle{Interpretation terms: extension of system~$\Fomega$}
  Reductions:
  \begin{enumerate}
  \item\label{arrW:mono:abs}
    if $s \arrW t$ then both $\abs{x}{s} \arrW \abs{x}{t}$ and
    $\tabs{\alpha}{s} \arrW \tabs{\alpha}{t}$
  \item\label{arrW:mono:right}
    if $s \arrW t$ then $\app{u}{s} \arrW \app{u}{t}$
  \item\label{arrW:mono:left}
    if $s \arrW t$ then both $\app{s}{u} \arrW \app{t}{u}$ and
    $\tapp{s}{\sigma} \arrW \tapp{t}{\sigma}$
  \item\label{arrW:beta:abs} $\app{(\abs{x:\sigma}{s})}{t} \arrW
    s[\subst{x}{t}]$
    and
    $\tapp{(\tabs{\alpha}{s})}{\sigma}
    \arrW s[\subst{\alpha}{\sigma}]$
    ($\beta$-reduction)
  \item\label{arrW:plus:base}
    $\app{\app{\oplus_{\nat}}{n}}{m} \arrW n+m$
    and
    $\app{\app{\otimes_{\nat}}{n}}{m}
    \arrW n \times m$
  \item\label{arrW:circ:arrow} $\app{\app{\circ_{\sigma \arrtype
        \tau}}{s}}{t} \arrW
    \abs{x:\sigma}{\app{\app{\circ_\tau}{(\app{s}{x})}}{(\app{t}{x})}}$
    for $\circ \in \{ \oplus, \otimes \}$
  \item\label{arrW:circ:forall}
    $\app{\app{\circ_{\quant{\alpha}{\sigma}}}{s}}{t} \arrW
    \tabs{\alpha}{\app{\app{\circ_\sigma}{(\tapp{s}{\alpha})}}{(
        \tapp{t}{\alpha})}}$ for $\circ \in \{ \oplus, \otimes \}$
  \item $\app{\flatten_\nat}{s} \arrW s$
  \item $\app{\flatten_{\sigma \arrtype \tau}}{s} \arrW
    \app{\flatten_\tau}{(\app{s}{(\app{\lift_\sigma}{0})})}$
  \item $\app{\flatten_{\quant{\alpha:\kappa}{\sigma}}}{s} \arrW
    \app{\flatten_{\sigma[\subst{\alpha}{\chi_\kappa}]}}{(\tapp{s}{\chi_\kappa})}$
  \item $\app{\lift_\nat}{s} \arrW s$
  \item $\app{\lift_{\sigma \arrtype \tau}}{s} \arrW
    \abs{x:\sigma}{\app{\lift_{\tau}}{s}}$
  \item $\app{\lift_{\quant{\alpha}{\sigma}}}{s} \arrW
    \tabs{\alpha}{\app{\lift_{\sigma}}{s}}$
  \end{enumerate}
\end{frame}

\begin{frame}{The well-founded order}
  The relation $s \succ_{\sigma} t$ is defined coinductively by:
  \[
  \begin{array}{c}
    \infer={s \succ_\nat t}{s\da > t\da \text{ in }\mathbb{N}} \\ \\
    \infer={s \succ_{\sigma\arrtype\tau} t}{\app{s}{q} \succ_{\tau} \app{t}{q} \text{ for all } q \in \Iterms^f_\sigma} \\ \\
    \infer={s \succ_{\forall(\alpha:\kappa).\sigma} t}{\tapp{s}{\tau} \succ_{\nf_\beta(\sigma[\subst{\alpha}{\tau}])} \tapp{t}{\tau} \text{ for all closed } \tau \in \Tc_{\kappa}}
  \end{array}
  \]
\end{frame}

\begin{frame}{The well-founded order}
  \framesubtitle{Infinite derivations}
  In any derivation of $s \succ_{\forall\alpha . \alpha} t$ there is an infinite branch.
  \[
  \infer={s \succ_{\forall \alpha . \alpha} t}{\infer={\tapp{s}{\forall\alpha.\alpha} \succ_{\forall \alpha . \alpha}
    \tapp{t}{\forall\alpha.\alpha}}{\infer={\tapp{\tapp{s}{\forall\alpha.\alpha}}{\forall \alpha . \alpha} \succ_{\forall \alpha . \alpha}
\tapp{\tapp{t}{\forall\alpha.\alpha}}{\forall\alpha.\alpha}}{\vdots} & \ldots} & \ldots}
  \]
\end{frame}


\end{document}
